<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">Samouczek Jetpack</string>
    <string name="back_again_to_close">Cofnij ponownie, aby zamknąć aplikację</string>
    <string name="settings">Ustawienia</string>
    <string name="select_app_language">Wybierz język aplikacji</string>
    <string name="polish">Polski</string>
    <string name="english">Angielski</string>

    <string name="app_theme">Motyw aplikacji</string>
    <string name="theme_auto">Automatyczny</string>
    <string name="theme_light">Jasny</string>
    <string name="theme_dark">Ciemny</string>

    <!-- Groups -->
    <string name="course_getting_started_title">Pierwsze kroki z Jetpack Compose</string>
    <string name="course_layout_title">Układ interfejsu</string>
    <string name="course_theming_styling">Stylizowanie interfejsu</string>
    <string name="course_getting_started_description">Poznaj podstawy Jetpack Compose, w tym konfigurację środowiska i tworzenie pierwszego elementu composable.</string>
    <string name="course_layout_description">Zagłęb się w układy Compose, motywy i stylizację swojej aplikacji.</string>
    <string name="curse_state_navigation_description">Efektywnie zarządzaj stanem i nawiguj między ekranami w aplikacji Compose.</string>
    <string name="course_advanced_description">Poznaj zaawansowane tematy Jetpack Compose, takie jak animacje, niestandardowe układy i optymalizacja wydajności.</string>
    <string name="completed">Ukończone</string>
    <string name="completed_percent">Ukończono %1$d%%</string>
    <string name="popup_continue">Kontynuuj</string>
    <string name="swipe_to_dismiss">Przesuń, aby ukryć</string>
    <string name="finish_lesson">Lekcja ukończona</string>

    <!-- Lessons -->
    <plurals name="lesson_pages">
        <item quantity="one">%d strona</item>
        <item quantity="few">%d strony</item>
        <item quantity="many">%d stron</item>
        <item quantity="other">%d stron</item>
    </plurals>

    <plurals name="incorrect_answers">
        <item quantity="one">niepoprawna odpowiedź.</item>
        <item quantity="few">niepoprawne odpowiedzi.</item>
        <item quantity="many">niepoprawnych odpowiedzi.</item>
    </plurals>

    <string name="lesson_introduction_title">Co to Jetpack Compose?</string>
    <string name="setting_up_environment_title">Konfigurowanie środowiska</string>
    <string name="creating_first_component_title">Tworzenie pierwszego komponentu</string>
    <string name="completed_n_of">Ukończono %1$d z %2$d lekcji</string>
    <string name="course_compose_basics_title">Podstawy Jetpack Compose</string>
    <string name="course_state_lifecycle">"Stan i cykl życia"</string>
    <string name="course_navigation">Nawigacja</string>
    <string name="course_animations">Animacje</string>
    <string name="course_advanced">Zaawansowane</string>
    <string name="clear_all_progress">Usuń wszystkie postępy</string>
    <string name="dialog_cancel">Anuluj</string>
    <string name="dialog_clear_progress">Usuń postępy</string>
    <string name="dialog_clear_title">Usuń wszystkie postępy</string>
    <string name="dialog_clear_text">Czy na pewno chcesz zresetować postęp we wszystkich kursach? Tej akcji nie można cofnąć.</string>
    <string name="popup_start">Zaczynajmy</string>
    <string name="enabled">Włączone</string>
    <string name="disabled">Wyłączone</string>
    <string name="select_app_theme">Wybierz motyw aplikacji</string>
    <string name="app_language">Język aplikacji</string>
    <string name="lesson_popup">Następna lekcja</string>
    <string name="lesson_popup_options">Wyświetlanie następnej lekcji</string>
    <string name="lesson_text_title">Wyświetlanie tekstu</string>
    <string name="text_8_heading">Konfiguracja układ tekstu</string>
    <string name="font_small">Mała</string>
    <string name="font_medium">Średnia</string>
    <string name="font_big">Duża</string>
    <string name="code_listing_font">Czcionka wyświetlanego kodu</string>
    <string name="select_listing_font">Wybierz czcionkę wyświetlanego kodu</string>
    <string name="text_1_heading">Wyświetlanie zwykłego tekstu</string>
    <string name="text_1_1">Najprostszym sposobem, aby wyświetlić tekst jest użycie funkcji kompozycyjnej |Text|.\nPosiada ona jeden wymagany parametr: string do wyświetlenia.</string>
    <string name="text_1_2">Ten kod wyświetli następujący tekst:</string>
    <string name="text_2_heading">Stylizacja tekstu</string>
    <string name="text_2_1">Funkcja kompozycyjna |Text| posiada wiele opcjonalnych parametrów, których możesz użyć, aby zmienić wygląd wyśweitlanego tekstu.</string>
    <string name="text_2_2">Zmiana koloru tekstu:</string>
    <string name="text_2_3">Zmiana rozmiaru tekstu:</string>
    <string name="text_4_heading">Modyfikowanie czcionki</string>
    <string name="text_4_1">Wyświetlanie tekstu jako kursywę:</string>
    <string name="text_4_2">Wyświetlanie tekstu jako pogrubiony:</string>
    <string name="text_4_3">Jetpack Compose oferuje również inne grubości czcionek: |Thin|, |ExtraLight|, |Light|, |Normal|, |Medium|, |SemiBold|, |ExtraBold| i |Black|.\nMożesz również utworzyć niestandardową grubość czcionki, przekazując odpowiednią wartość Int do konstruktora.</string>
    <string name="text_6_heading">Zaawansowana stylizacja</string>
    <string name="text_6_1">Możesz dodać cień do tekstu, tworząc nowy TextStyle i określając kolor, przesunięcie oraz promień rozmycia cienia.</string>
    <string name="text_5_heading">Ozdoby tekstu</string>
    <string name="text_5_1">Rysowanie poziomej linii na tekście:</string>
    <string name="text_5_2">Możesz połączyć dekoracje tekstu za pomocą funkcji |TextDecoration.combine| lub operatora dodawania:</string>
    <string name="text_7_heading">Zaawansowana stylizacja - wiele stylów</string>
    <string name="text_7_1">Możesz użyć kilku styli w jednej funkcji |Text| za pomocą klasy |AnnotatedString|. Funkcja pomocnicza |buildAnnotatedString| pozwala na łatwe dodawanie fragmentów tekstu z róznymi stylami.</string>
    <string name="text_9_heading">Wyświetlanie tekstu z zasobów</string>
    <string name="text_9_1">Rekomendowanym podejściem do wyświetlania tekstu jest wykorzystywanie zasobów (string resources), zamiast wpisywania wartości na sztywno w kodzie.\nPozwala to na łatwiejsze użycie tego samego tekstu w wielu miejsach, zmniejszając przy tym szansę na pomyłkę.\nDodatkowo, ułatwia to znacząco przygotowanie aplikacji do obsługi wielu języków.</string>
    <string name="hello_world">Witaj, świecie! (po polsku)</string>
    <string name="text_8_1">Możesz ograniczyć liczbę wyświetlanych linijek dla długich tekstów:</string>
    <string name="text_8_2">Dodatkowo, możesz również zaznaczyć przepełnienie tekstu:</string>
    <string name="text_3_heading">Zmiana czcionki</string>
    <string name="text_3_1">Użycie czcionki o stałej szerokości</string>
    <string name="text_3_2">Jetpack compose udostępnia również inne czcionki: |Default|, |SansSerif|, |Serif| i |Cursive|. Możesz też użyć własnej czcionki, gdy zaimportujesz ją do projektu.</string>
    <string name="button_1_heading">Tworzenie zwykłego przycisku</string>
    <string name="lesson_button_title">Przyciski</string>
    <string name="button_1_1">Aby stworzyć przycisk, możesz użyć funkcji kompozycyjnej |Button|.\nFunkcja ta ma dwa wymagane parametry: treść do wyświetlenia oraz wywołanie zwrotne (callback), które zostanie uruchomione, gdy użytkownik kliknie przycisk.</string>
    <string name="button_2_heading">Wykonywanie akcji po kliknięciu</string>
    <string name="button_2_1">Aby wykonać jakąś akcję gdy użytkownik wciśnie przyckisk, możesz przekazać do parametru |onClick| funkcję, która zostanie wykonana po kliknięciu.</string>
    <string name="button_2_2">Użyte w kodzie |remember| i |mutableIntStateOf| będą opisane w późniejszych lekcjach.</string>
    <string name="button_3_heading">Rodzaje przycisków</string>
    <string name="button_3_1">Jetpack Compose udostępnia 5 predefiniowanych typów przycisków: filled (domyślny), tonal, outlined, elevated i text.\nMożesz wybrać ten, który najlepiej pasuje do stylu aplikacji oraz jego funkcji.</string>
    <string name="button_4_heading">Przyciski z ikonami</string>
    <string name="button_4_1">Kolejnym rodzajem przycisku jest przycisk z ikoną. Zazwyczaj zawiera w sobie jedną ikoną (ale może być to coś innego).\nDostępne są 3 rodzaje: domyślny, filed i outlined.</string>
    <string name="button_5_heading">Przyciski przełączające</string>
    <string name="button_5_1">"Przyciski z ikonami mogą być również użyte jako przełączniki.\nTaki przycisk posiada dwa wymagane parametry: obecny stan przełącznika (boolean) i funkcja, która będzie wywoływana przy zmianie tego stanu.\nDostępne są trzy rodzaje przycisków przełączejących: filled, tonal i outlined. "</string>
    <string name="button_1_2">Możesz wyłączyć przycisk poprzez ustawienie parametru |enabled| na false.</string>
    <string name="button_6_heading">Dostosowywanie kolorów</string>
    <string name="button_6_1">Możesz zmienić kolory przycisku tworząc |ButtonColors| i przekazując je do funkcji kompozycyjnej:</string>
    <string name="button_7_heading">Modyfikoanie kształtu</string>
    <string name="button_7_1">Możesz zmienić kształt przycisku przekazując utworzony niestandardowy kształt.\nMargines wewnętrzny zawartości można również określić za pomocą parametru |contentPadding|.</string>
    <string name="button_8_heading">Obramowanie</string>
    <string name="button_8_1">Możesz dodać obramowanie do przycisku za pomocą parametru |border|.\nObramowanie może mieć jednolity kolor lub gradient.</string>
    <string name="lesson_toast_title">Powiadomienia toast</string>
    <string name="toast_requires_newer_api">Ten podgląd wymaga 30 poziom API (Android 11).</string>
    <string name="toast_1_heading">Wyświetlanie powiadomień toast</string>
    <string name="toast_2_heading">Dodawanie wywołań zwrotnych (callback)</string>
    <string name="toast_3_heading">Anulowanie wiadomości</string>
    <string name="lesson_text_field_title">Pola tekstowe</string>
    <string name="text_field_1_heading">Tworzenie pola tekstowego</string>
    <string name="text_field_2_heading">Ograniczanie liczby linii</string>
    <string name="text_field_3_heading">Pola wyłączone i tylko do odczytu</string>
    <string name="text_field_4_heading">Dekorowanie pól tekstowych</string>
    <string name="text_field_5_heading">Dodawanie prefixu i suffixu</string>
    <string name="text_field_6_heading">Transformacje wizualne</string>
    <string name="text_field_7_heading">Typy klawiatur</string>
    <string name="text_field_8_heading">Akcja IME</string>
    <string name="text_field_9_heading">Dostosowywanie wyglądu</string>
    <string name="lesson_image_title">Obrazy</string>
    <string name="image_1_heading">Wyświetlanie obrazów</string>
    <string name="image_2_heading">Grafika wektorowa</string>
    <string name="image_3_heading">Modyfikowanie wartości alpha</string>
    <string name="image_4_heading">Nakładanie filtru kolorów</string>
    <string name="image_5_heading">Nakładanie barwy</string>
    <string name="image_6_heading">Skalowanie obrazu</string>
    <string name="lesson_card_title">Karty</string>
    <string name="card_1_heading">Tworzenie karty</string>
    <string name="card_2_heading">Typy kart</string>
    <string name="card_3_heading">Dostosowywanie wyglądu</string>
    <string name="lesson_modifier_title">Używanie modyfikatorów</string>
    <string name="modifier_1_heading">Stosowanie modyfikatora</string>
    <string name="modifier_2_heading">Kolejność ma znaczenie</string>
    <string name="modifier_3_heading">Zmienianie rozmaru</string>
    <string name="modifier_4_heading">Dodawanie marginesów</string>
    <string name="modifier_5_heading">Przewijanie zawartości</string>
    <string name="modifier_6_heading">Klikanie elementów</string>
    <string name="modifier_7_heading">Przeciąganie</string>
    <string name="modifier_8_heading">Animowanie rozmiaru</string>
    <string name="modifier_9_heading">Rozmycie</string>
    <string name="modifier_10_heading">Wycinanie kształtów</string>
    <string name="modifier_12_heading">Warunkowy modyfikator</string>
    <string name="modifier_13_heading">Wielokrotne użycie modyfikatora</string>
    <string name="modifier_11_heading">Dostępność</string>
    <string name="modifier_1_1">Dzięki modyfikatorom możesz zmieniać wygląd lub modyfikować zachowanie funkcji kompozycyjnych.\nWszystkie opisane wcześniej funkcje kompozycyjne posiadają opcjonalny parametr: modyfikator.</string>
    <string name="modifier_2_1">Kolejność użycia modyfikatorów ma znaczenie. Każda funkcja zmienia modyfikator zwrócony przez poprzednią funkcję, co sprawia że układ sekwencji ma wpływ na wynik końcowy.</string>
    <string name="modifier_2_2">W pierwszym przykładzie czerwone tło jest zauważalnie mniejsze niż w drugim, ponieważ jest ono dodane po marginesie, który ogranicza dostępne miejsce dla następnych modyfikatorów.</string>
    <string name="modifier_3_1">Możesz zmienić rozmiar funkcji kompozycyjnych stosując modyfikator |size|, |height| lub |width|.\nMożesz również zająć całą dostępną przestrzeń (lub część) używając modyfikatorów |fillMaxSize|, |fillMaxWidth| lub |fillMaxHeight|.</string>
    <string name="modifier_4_1">Możesz dodać marginesy za pomocą modyfikatora |padding|.\nMoże on dodać takie same marginesy na wszystkich stronach, na krawędzi pionowej i poziomej, lub inne z każdej strony.</string>
    <string name="modifier_5_1">Możesz dodać funkcję przewijania, aby wyświetlać większe elementy.\nModyfikatory |verticalScroll| and |horizontalScroll| umożliwiają na przewijanie w odpowiednim kierunku.\nModyfikatory te dodatkowo wymagają przekazania stanu przewijania, zazwyczaj w postaci funkcji |rememberScrollState()|.</string>
    <string name="modifier_6_1">Każda funkcja kompozycyjna może reagować na kliknięcia dzięki modyfikatorowi |clickable|.\nWymaga on podania funkcji do wywołania po każdym kliknięciu, podobnie jak przyciski.</string>
    <string name="modifier_6_2">Możliwe jest również wykonywanie różnych akcji po podwójnym i długim kliknięciu.\nMożesz to osiągnąć za pomocą modyfikatora  |combinedClickable|.</string>
    <string name="modifier_7_1">Funkcje kompozycjne można również przeciągać, po zastosowaniu modyfikatorów |draggable| i |offset|.\nAby umożliwić przeciąganie w dwóch osiach, możesz zastąpić modyfikator |draggable| przez |pointerInput| i manualnie zmieniać wartości przesunięcia w obu osiach.</string>
    <string name="modifier_8_1">Kiedy rozmiar zawartości może się zmieniać, możesz użyć modyfikatora |animateConentSize| aby płynnie animować zmiany.</string>
    <string name="modifier_9_1">Możesz rozmyć funkcje kompozycyjne za pomocą modyfikatora |blur|.\nWymaga on podania promienia rozmycia oraz, opcjonalnie, jak traktować krawiędzie obszaru rozmycia.</string>
    <string name="modifier_10_1">Możesz wyciąć kształt z zawartości dzięki modyfikatorowi |clip|.\nBardziej skomplikowane kształty można osiągnać poprzez użycie tego modyfikatora wiele razy.</string>
    <string name="modifier_11_1">Możesz dodać informacje dostępności do swojego interfejsu za pomocą modfikatora |sematnics|.\nMoże on określić rolę konkrentych elementów interfejsu oraz opisać ich stan na użytek usług dostępności.</string>
    <string name="modifier_12_1">Modifykatory mogą być nakładane warunkowo, dzięki użyciu funkcji |Modifier.then|.</string>
    <string name="modifier_13_1">Modyfikatory są zwykłymi obiektami języka Kotliin - możesz utworzyć jeden i wykorzytsać go później w wielu miejscach.</string>
    <string name="text_field_1_1">Pola tekstowe pozwalają użytkownikom na wprowadzanie tekstu. Aby je utwożyć, możesz wykorzystać funkcję kompozycjną |TextField|.\nPosiada ona dwa wymanagne parametry: obecnie wyświetlany tekst oraz funkcje wywoływaną na każdej zmianie wprowadzonego tekstu.</string>
    <string name="text_field_1_2">Możesz dodać tekst zastępczy, który będzie widoczny, gdy nie wprowadzono żadnego tekstu, za pomocą parametru |placeholder|.</string>
    <string name="text_field_2_1">Możesz ograniczyć pole tekstowe tylko do jednej linii, za pomocą parametru |singleLine|.\nMożesz również zmienić minimalną i maksymalną liczbę wyświetlanych linii parametrami |minLines| i |maxLines|.</string>
    <string name="text_field_3_1">Parametry |enabled| i |readOnly| mogą odpowiednio, wyłączyć pole tekstowe i zablokować możliwość edytowaniea tekstu.</string>
    <string name="text_field_4_1">Możesz dodać więcej informacji wizualnych do pola tekstowego za pomocą parametrów |label|, |supportingText|, |leadingIcon| i |trailingIcon|.</string>
    <string name="text_field_5_1">Możesz również dodać |prefix| i |suffix|, które będą wyświetlane wokół wprowadzonego tekstu.</string>
    <string name="text_field_6_1">Tekst można przekształcić wizualnie za pomocą parametru |visualTransformation|.\nMoże to być przydatne na przykład podczas wprowadzania haseł lub kodów pocztowych.\nJetpack Compose zapewnia gotową transformację wizualną haseł: |PasswordVisualTransformation|.</string>
    <string name="text_field_6_2">Możliwe jest utworzenie niestandardowej transformacji wizualnej. |CustomVisalTransformation| zastępuje widoczne litery cyframi 0–9 w zależności od ich położenia.\nWarto podkreślić, że rzeczywista wartość tekstowa pozostaje niezmieniona; nadal zawiera dokładnie to, co wprowadził użytkownik.</string>
    <string name="text_field_7_1">Możesz zmodyfikować pole tekstowe, aby wyświetlić użytkownikowi różne typy klawiatury za pomocą parametru |keyboardOptions|.\nAby mieć pewność, że wprowadzony tekst zawiera tylko dozwolone symbole (np. liczby), możesz filtrować wprowadzony tekst w wywołaniu zwrotnym |onValueChanged|.</string>
    <string name="text_field_8_1">Można zmienić akcję IME wyświetlaną na klawiaturze, tworząc obiekt |KeyboardOptions| z określoną akcją IME i przekazując go do funkcji kompozycyjnej.</string>
    <string name="text_field_9_1">Możesz zmienić wygląd pola tekstowego, przekazując niestandardowe parametry |TextFieldColors| i |TextStyle| do funkcji kompozycyjnej.</string>
    <string name="image_1_1">Aby wyświetlić obraz, możesz użyć fukncji kompozycujnej |Image|.\nMa dwa wymagane parametry: |painter|, który jest odpowiedzialny za rysowanie obrazu (zwykle |painterResource|) i |contentDescroption| używanego przez usługi ułatwień dostępu.\n|Image| może wyświetlić obrazy w formacie png, jpg i webp.</string>
    <string name="image_2_1">Funkcja kompozycyjna |Image| może również wyświetlać grafikę wektorową.\nPlik opisujący grafikę powinien być w formacie xml.</string>
    <string name="image_3_1">Wartość alfa wyświetlanego obrazu możesz modyfikować za pomocą parametru |alpha|.</string>
    <string name="image_4_1">Parametr |colorFilter| umożliwia modyfikację wartości kolorów każdego piksela na obrazie.\nMożesz go użyć do zmiany nasycenia, przesunięcia odcienia lub ręcznego dostosowania wartości.</string>
    <string name="image_5_1">Możesz również nakładać barwę na obraz za pomocą parametru |color Filter|.\nDostępnych jest wiele trybów mieszania kolorów, z których każdy daje inne efekty.</string>
    <string name="image_6_1">Możesz zmienić sposób skalowania obrazu w jego granicach, używając parametru |contentScale|.\nJeśli nie określisz tego parametru, domyślnie zostanie użyty |ContentScale.Fit|.</string>
    <string name="card_1_1">Karty służą jako kontenery dla interfejsu aplikacji.\nKarta zazwyczaj przedstawia pojedyńczy spójny element treści, taki jak artykuł w aplikacji informacyjnej lub wiadomość w aplikacji komunikatora.</string>
    <string name="card_1_2">Aby utworzyć kartę, możesz użyć funkcji kompozycyjnej |Card|. Posiada ona jeden wymagany parametr: treść do wyświetlenia.</string>
    <string name="card_1_3">Kartę można uczynić klikalną poprzez podanie funkcji do parametru wywołania zwrotnego |onClick|.</string>
    <string name="card_2_1">Jetpack Compose oferuje również inne warianty kart: |ElevatedCard| i |OutlinedCard|.</string>
    <string name="card_3_1">Możesz dostosować kolory, kształt i obramowanie karty, przekazując niestandardowe wartości do parametrów |colors|, |shape| i |border|.</string>
    <string name="toast_1_1">Toast to mała wiadomość pop-up, która zapewnia informacje zwrotne na temat operacji.\nZajmuje niewielką ilość miejsca i znika automatycznie po upływie limitu czasu.</string>
    <string name="toast_1_2">Aby wyświetlić wiadomość toast, musisz najpierw utworzyć obiekt Toast.\nMożesz to zrobić za pomocą metody |Toast.makeText|, która przyjmuje następujące parametry: |Context| powiązany z wiadomością, tekst do wyświetlenia i czas trwania tosta.\nW Jetpack Compose, można łatwo uzykać dostęp do konteksu za pomocą funkcji kompozycyjnej |LocalContext.Current|.\n\nPo utworzeniu obiektu toastu możesz użyć metody |call| na nim, aby wyświetlić go na ekranie.</string>
    <string name="toast_2_1">Możesz dodać wywołania zwrotne do tosta, aby wiedzieć, kiedy jest on wyświetlany i ukrywany.\nAby to zrobić, możesz utworzyć obiekt dziedziczący po |Toast.Callback| i zarejestrować go za pomocą metody |addCallback|.</string>
    <string name="toast_3_1">Możesz ograniczyć czas widoczności wiadomości wywołując metodę |cancel|, aby ukryć ją wcześniej.</string>
    <string name="quiz_question_n_of">Pytanie %1$d z %2$d</string>
    <string name="quiz_check">Sprawdź</string>
    <string name="lesson_more_challenge">Przejdź do wyzwania</string>
    <string name="code_challenge">Wyzwanie</string>
    <string name="start_quiz">Rozpocznij quiz</string>
    <string name="quiz_finished">Quiz zakończony</string>
    <string name="quiz_answered_correctly_n_of">Odpowiedziałeś(-aś) poprawnie na %1$d z %2$d pytań.</string>
    <string name="quiz_restart">Restartuj quiz</string>
    <string name="quiz_continue">Kontynuuj</string>
    <string name="no_shuffle">Nie mieszaj</string>
    <string name="shuffle_questions">Mieszaj pytania</string>
    <string name="shuffle_all">Miejszaj pytania i odpowiedzi</string>
    <string name="select_quiz_shuffle">Wybierz tryb losowania</string>
    <string name="quiz_shuffling_mode">Losownanie pytań quizu</string>
    <string name="challenge_show_code">Pokaż kod</string>
    <string name="challenge_hide_code">Ukryj kod</string>
    <string name="quiz_text_1">Której funkcji kompozycyjnej można użyć do wyświetlania tekstuw Jetpack Compose?</string>
    <string name="quiz_introduction_1">Który język programowania jest głównie używany w Jetpack Compose?</string>
    <string name="quiz_text_2">Jak można zmienić rozmiar czcionki tekstu w Jetpack Compose?</string>
    <string name="quiz_text_2_1">Stosując *FontModifier* na tekście</string>
    <string name="quiz_text_2_2">Korzystając z parametru *fontSize*</string>
    <string name="quiz_text_2_3">Rozmiaru czcionki nie można zmienić</string>
    <string name="quiz_text_3">Którego parametru można użyć do zmiany koloru tekstu?</string>
    <string name="quiz_text_4">Jaka klasa może przechowywać tekst i jego styl?</string>
    <string name="introduction_1_heading">Jetpack compose</string>
    <string name="introduction_1_1">Jetpack Compose to zalecany zestaw narzędzi do tworzenia interfejsu użytkownika dla aplikacji na Androida.\nUproszcza i przyspiesza rozwój interfejsu użytkownika, umożliwiając tworzenie aplikacji przy użyciu mniejszej ilości kodu, porzydatnych narzędzi i intuicyjnych interfejsów API Kotlin.</string>
    <string name="introduction_2_heading">Deklaratywny interfejs z funkcjami kompozycyjnymi</string>
    <string name="introduction_2_1">W Jetpack Compose elementy interfejsu użytkownika są tworzone jako funkcje, nazywane funkcjami kompozycyjnymi (composables).\nFunkcje te opisują strukturę i wygląd interfejsu użytkownika w deklaratywny sposób.</string>
    <string name="introduction_2_2">Zmiana stanu funkcji kompozycyjnych automatycznie wywołuje aktualizację interfejsu użytkownika, eliminując potrzebę ręcznego odświeżania.</string>
    <string name="introduction_3_heading">Główne zalety Jetpack Compose</string>
    <string name="introduction_3_1">Jetpack Compose oferuje kluczowe korzyści w porównaniu z tradycyjnym podejściem opartym na XML:</string>
    <string name="introduction_3_2">Lepsza czytelność kodu</string>
    <string name="introduction_3_3">Łatwiejsza konserwacja</string>
    <string name="introduction_3_4">Łatwo dostosowywalny do istniejących projektów</string>
    <string name="introduction_3_5">Funkcje takie jak podgląd na żywo, hot reload i pełne wsparcie Android Studio sprawiają, że tworzenie aplikacji za pomocą Jetpack Compose jest łatwiejsze i szybsze.</string>
    <string name="lesson_setting_up_environment_title">Ustawianie środowiska</string>
    <string name="setting_up_1_1">Aby w pełni wykorzystać możliwości programowania z Compose, pobierz i zainstaluj Android Studio.\nZawiera ono wiele inteligentnych funkcji edytora, takich jak nowe szablony projektów oraz możliwość natychmiastowego podglądu interfejsu użytkownika i animacji</string>
    <string name="setting_up_1_2">Tworzenie nowego projektu</string>
    <string name="setting_up_1_3">Aby utworzyć nowy projekt z poprawnie skonfigurowanym Jetpack Compose, wykonaj następujące czynności:</string>
    <string name="setting_up_1_4">Kliknij *Start a new Android Studio project*.</string>
    <string name="setting_up_1_5">W oknie *Sekect a Project Template* wybierz *Empty Activity* i kliknij *Next*.</string>
    <string name="setting_up_1_6">W oknie *Configure your project* ustaw *Name*, *Package name* i *Save locationu* tak, jak zwykle.\nW menu rozwijanym *Minimum API level* wybierz poziom API 21 lub wyższy.</string>
    <string name="setting_up_1_7">Kliknij *Finish*.</string>
    <string name="setting_up_2_heading">Konfigurowanie istniejącej aplikacji</string>
    <string name="setting_up_2_1">Skonfiguruj kompilator Compose za pomocą pluginu *Compose Compiler Gradle* i dodaj następującą definicję do pliku |build.gradle| swojej aplikacji:</string>
    <string name="setting_up_2_2">Ustawienie flagi |compose| na |true| wewnątrz bloku funkcji kompilacji włącza funkcjonalność Compose w Android Studio.</string>
    <string name="setting_up_2_3">Na koniec dodaj Compose BOM i biblioteki Compose, których planujesz użyć, w bloku |dependencies|:</string>
    <string name="setting_up_3_heading">Przykładowe aplikacje Jetpack Compose</string>
    <string name="setting_up_3_1">Najszybszym sposobem na eksperymentowanie z Jetpack Compose jest wypróbowanie przykładowych aplikacji.\nAby zaimportować przykładowy projekt aplikacji z Android Studio, wykonaj następujące czynności:</string>
    <string name="setting_up_3_2">Na ekranie powitalnym Android Studio wybierz opcję *Import an Android code sample*.</string>
    <string name="setting_up_3_3">W górnym pasku wyszukiwania wpisz „compose”.</string>
    <string name="setting_up_3_4">Wybierz jedną z przykładowych aplikacji Jetpack Compose z wyników wyszukiwania i kliknij *Next*.</string>
    <string name="setting_up_3_6">Zmień *Application name* i *Project location* lub zachowaj wartości domyślne.</string>
    <string name="setting_up_3_5">Kliknij *Finish*.</string>
    <string name="setting_up_3_7">Android Studio pobiera przykładową aplikację i otwiera projekty.\nNastępnie możesz sprawdzić plik |MainActivity.kt|, aby zobaczyć przykładowe użycie interfejsów API Jetpack Compose.</string>
    <string name="setting_up_4_heading">Uruchamianie aplikacji na urządzeniach wirtualnych</string>
    <string name="setting_up_4_1">Emulator Androida pozwala testować aplikację na wielu różnych urządzeniach wirtualnych. Emulator jest dołączony do Android Studio.\nAby użyć emulatora, wykonaj następujące kroki:</string>
    <string name="setting_up_4_2">Wymagania systemowe emulatora</string>
    <string name="setting_up_4_4">64-bitowy Windows 10 lub nowszy, MacOS 12 lub nowszy, Linux lub ChromeOS</string>
    <string name="setting_up_4_5">16 GB miejsca na dysku</string>
    <string name="setting_up_4_6">Utwórz wirtualne urządzenie Android (AVD)</string>
    <string name="setting_up_4_7">Każda instancja emulatora Androida używa AVD do określenia wersji Androida i sprzętu symulowanego urządzenia.\nAby utworzyć AVD, możesz użyć *Device Manager*.</string>
    <string name="setting_up_4_8">Po utworzeniu AVD możesz uruchomić emulator Androida i uruchomić swój projekt:</string>
    <string name="setting_up_4_9">Na pasku narzędzi wybierz AVD, na którym chcesz uruchomić swoją aplikację.</string>
    <string name="setting_up_4_10">Kliknij *Run*. Pierewsze uruchomienie emulatora może zająć dłuższą chwilę.</string>
    <string name="setting_up_5_heading">Uruchamianie aplikacji na urządzeniu lokalnym</string>
    <string name="setting_up_5_1">Zanim uruchomisz aplikację na swoim urządzeniu, musisz włączyć *Debugowanie USB* w *Opcjach programisty*.\nPo podłączeniu urządzenia do komputera za pomocą kabla USB możesz kliknąć *Uruchom* w Android Studio, aby zbudować i uruchomić aplikację na urządzeniu.</string>
    <string name="quiz_introduction_2">Jak nazywa się element interfejsu użytkownika w Jetpack Compose?</string>
    <string name="quiz_introduction_2_1">Composable (funkcja kompozycyjna)</string>
    <string name="quiz_introduction_3">Jak definiuje się composable w Jetpack Compose?</string>
    <string name="quiz_introduction_3_1">Jako klasę</string>
    <string name="quiz_introduction_3_2">Jako funkcję</string>
    <string name="quiz_introduction_3_3">Jako wartość stałą</string>
    <string name="quiz_setting_up_1">Które środowisko IDE jest zalecane dla Jetpack Compose?</string>
    <string name="quiz_setting_up_2">Czy Android Studio pozwala na testowanie aplikacji na urządzeniach wirtualnych?</string>
    <string name="quiz_setting_up_2_1">Tak, korzystając z Phone Virtualization System</string>
    <string name="quiz_setting_up_2_2">Tak, używając Android Emulator</string>
    <string name="quiz_setting_up_2_3">Nie</string>
    <string name="creating_first_2_heading">Funkcje kompozycyjne</string>
    <string name="creating_first_2_1">Jetpack Compose jest zbudowany wokół funkcji kompozycyjnych.\nFunkcje te pozwalają programowo definiować interfejs użytkownika aplikacji, opisując, jak powinien wyglądać i dostarczając danych, zamiast skupiać się na procesie konstrukcji interfejsu użytkownika.\nAby utworzyć funkcję kompozycyjną, wystarczy dodać adnotację |@Composable| do nazwy funkcji.</string>
    <string name="creating_first_1_heading">Witaj, Świecie!</string>
    <string name="lesson_creating_first_title">Tworzenie pierwszej funkcji kompozycyjnej</string>
    <string name="creating_first_1_1">Aby wyświetlić prosty tekst na ekranie, możesz użyć funkcji kompozycyjnej |Text| wewnątrz bloku |setContent|.\nBlok ten działa jako punkt wejścia dla wszystkich interfejsów użytkownika utworzonych w Jetpack Compose.</string>
    <string name="creating_first_1_2">Android Studio powinno automatycznie zaimportować wymaganą funkcję.\nJeśli tak się jednak nie stało, możesz spróbować dodać linię importu ręcznie.</string>
    <string name="creating_first_2_2">Funkcje kompozycyjne można wywołać tylko z innych funkcji kompozycyjnych lub z punktów wejściowych (np. bloku |setContent|).</string>
    <string name="creating_first_3_1">Możesz wyświetlić podgląd swoich funkcji kompozycyjnych w Android Studio, dodając adnotację |@Preview|.\nAby wyświetlić podgląd, funkcja nie może przyjmować żadnych jawnych parametrów.\nCzęstą praktyką jest tworzenie drugiej funkcji, która wywołuje poprzednią z odpowiednimi argumentami.</string>
    <string name="creating_first_3_heading">Wyświetlanie podglądu</string>
    <string name="creating_first_3_2">Po utworzeniu podglądu należy odbudować projekt.\nSama aplikacja się nie zmienia, ponieważ funkcja podglądu nie jest nigdzie wywoływana, ale Android Studio dodaje okno podglądu.\nMożesz rozszerzyć to okno, klikając przycisk widoku podzielonego (design/kod).</string>
    <string name="creating_first_3_label_1">Przyciski okna podglądu</string>
    <string name="creating_first_3_label_2">Widoczne okno podglądu w trybie podzielonego ekranu</string>
    <string name="setting_up_4_label_1">Okno wyboru urządzenia</string>
    <string name="lesson_more_quiz">Przejdź do quizu</string>
    <string name="creating_first_4_heading">Używanie utworzonych funkcji kompozycyjnych</string>
    <string name="creating_first_4_1">Aby użyć funkcji kompozycyjnej w aplikacji, należy uwzględnić ją w hierarchii interfejsu użytkownika, wywołując ją w punkcie wejściowym.</string>
    <string name="creating_first_4_2">Niektóre composble akceptują inne funkcje composable jako parametr.\nMoże to być przydatne do tworzenia bardziej zaawansowanych układów bez nadmiernego komplikowania kodu.</string>
    <string name="quiz_creating_first_1">Gdzie można wywoływać funkcje kompozycyjne?</string>
    <string name="quiz_creating_first_2">Jakiej adnotacji można użyć do wyświetlenia utworzonego elementu kompozycji w Android Studio?</string>
    <string name="quiz_creating_first_3">W jaki sposób można wyświetlić podgląd funkcji kompozycyjnej wymagającej podania parametrów?</string>
    <string name="quiz_creating_first_1_1">We wszystkich miejscach, w których można wywołać zwykłe funkcje</string>
    <string name="quiz_creating_first_1_2">Tylko w pliku z klasą *MainActivity*</string>
    <string name="quiz_creating_first_1_3">Z innych funkcji kompozycyjnych lub punktów wejściowych</string>
    <string name="quiz_creating_first_3_1">Używając domyślnych argumentów</string>
    <string name="quiz_creating_first_3_2">Tworząc funkcję podglądu, która dostarcza wymagane parametry</string>
    <string name="quiz_creating_first_3_3">Podgląd można stosować tylko w przypadku funkcji bez parametrów</string>
    <string name="quiz_button_1_1">Tak, możesz wyświetlić dowolną funkcję kompozycjną wewnątrz przycisku</string>
    <string name="quiz_button_1_2">Tak, ale dozwolone są tylko funkcje kompozycyjne oznaczone adnotacją *@Interactable*</string>
    <string name="quiz_button_1_3">Nie, możesz umieścić tylko tekst wewnątrz przycisków</string>
    <string name="quiz_button_2">Jakiej funkcji kompozycyjnej możesz użyć, aby utworzyć przycisk, na którym widoczny będzie tylko tekst?\n</string>
    <string name="quiz_text_field_1">Jak można ustawić liczbę widocznych wierszy w polu tekstowym?</string>
    <string name="quiz_text_field_1_1">Za pomocą parametrów *minLines* i *maxLines*</string>
    <string name="quiz_text_field_1_2">Za pomocą parametru *visibleLines*</string>
    <string name="quiz_text_field_1_3">Tylko poprzez modyfikację wyświetlanej wartości tekstowej</string>
    <string name="quiz_text_field_2">Czy można zmienić wygląd wprowadzanego tekstu?</string>
    <string name="quiz_text_field_2_1">Tak, używając parametru *textMapper*</string>
    <string name="quiz_text_field_2_2">Tak, używając parametru *visualTransformation*</string>
    <string name="quiz_text_field_2_3">Tak, używając klasy *AnnotatedString*</string>
    <string name="quiz_text_field_2_4">Tylko poprzez niestandardową implementację</string>
    <string name="quiz_text_field_3">Którego parametru można użyć do wyświetlenia klawiatury numerycznej?</string>
    <string name="quiz_image_1">W jaki sposób można utworzyć obiekt *Painter*, który jest wymaganym parametrem funkcji kompozycyjnej *Image*?</string>
    <string name="quiz_image_1_1">Używając klasy *ImagePainterFactory*</string>
    <string name="quiz_image_1_2">Używając funkcji *painterResource*</string>
    <string name="quiz_image_1_3">Obiekty *Painter* tworzone są automatycznie dla każdego obrazu</string>
    <string name="quiz_image_2">Jakie czynności są wymagane do narysowania grafiki wektorowej przy użyciu kompozycji obrazu?</string>
    <string name="quiz_image_2_1">Rzutowanie *VectorDrawable* na *Bitmap*</string>
    <string name="quiz_image_2_2">Określanie typu obrazu za pomocą parametru format</string>
    <string name="quiz_image_2_3">Takie same jak przy rysowaniu obrazu rastrowego</string>
    <string name="quiz_modifier_1">Do jakich funkcji kompozycyjnych można stosować modyfikatory?</string>
    <string name="quiz_modifier_1_1">Do każdej</string>
    <string name="quiz_modifier_1_2">Tylko do tych z adnotacją *@Modifiable*</string>
    <string name="quiz_modifier_1_3">Do tych, które akceptują Modyfikator jako jeden z parametrów</string>
    <string name="quiz_modifier_2">Czy kolejność zastosowanych modyfikatorów wpływa na wynik?</string>
    <string name="quiz_modifier_2_1">Tak</string>
    <string name="quiz_modifier_2_2">Tak, jeśli modyfikator nie posiada adnotacji *@Stable*</string>
    <string name="quiz_modifier_2_3">Nie</string>
    <string name="quiz_modifier_3">Czy jest wymagane, aby tworzyć osobny modyfikator dla każdej funkcji kompozycyjnej?</string>
    <string name="quiz_modifier_3_1">Nie, jeśli funkcje kompozycjyjne są w tym samym pliku</string>
    <string name="quiz_modifier_3_2">Nie</string>
    <string name="quiz_modifier_3_3">Tak, wielokrotne użycie modyfikatorów może spowodować niechciane efekty uboczne</string>
    <string name="quiz_card_1">Jak można sprawić, by karta była klikalna?</string>
    <string name="quiz_card_1_1">Tworząc w środku niej przycisk</string>
    <string name="quiz_card_1_2">Przekazując wywołanie zwrotne do parametru *onClick*</string>
    <string name="quiz_card_1_3">Używając funkcji kompozycyjnej *ClickableCard*</string>
    <string name="quiz_card_2">Czy jest możliwe, aby zmienić kształt karty?</string>
    <string name="quiz_card_2_1">Nie, karty posiadają stały domyślny kształt</string>
    <string name="quiz_card_2_2">Tak, za pomocą parametru *cornerRadius*</string>
    <string name="quiz_card_2_3">Tak, poprzez podanie niestandardowego obiektu *Shape* dla parametru *shape*</string>
    <string name="lesson_box_title">Pudełko</string>
    <string name="lesson_column_row_title">Kolumna i rząd</string>
    <string name="lesson_grid_title">Siatka</string>
    <string name="lesson_scaffold_title">Rusztowanie (scaffold)</string>
    <string name="box_1_heading">Układanie elementów w pudełku</string>
    <string name="box_2_heading">Domyślne ułożenie</string>
    <string name="box_3_heading">Dopasowywanie rozmiaru</string>
    <string name="column_row_1_heading">Uzywanie układów</string>
    <string name="column_row_2_heading">Dodawanie zawartości</string>
    <string name="column_row_3_heading">Wyrównywanie zawartości</string>
    <string name="column_row_4_heading">Rodzaje ułożeń - kolumna</string>
    <string name="column_row_5_heading">Rodzaje ułożeń - rząd</string>
    <string name="column_row_6_heading">Waga</string>
    <string name="column_row_7_heading">Przewijanie zawartości</string>
    <string name="column_row_8_heading">Leniwe (lazy) kontenery</string>
    <string name="column_row_9_heading">Kontrolowanie przewijania</string>
    <string name="column_row_10_heading">Animowanie zmian zawartości</string>
    <string name="grid_1_heading">Tworzenie siatek</string>
    <string name="grid_2_heading">Rozmiar komórek</string>
    <string name="grid_3_heading">Pozioma siatka</string>
    <string name="grid_4_heading">Układ zawartości</string>
    <string name="grid_5_heading">Animowanie zmian zawartości</string>
    <string name="grid_6_heading">Kontrolowanie przewijania</string>
    <string name="grid_7_heading">Siatki schodkowe</string>
    <string name="scaffold_1_heading">Spójny układ UI</string>
    <string name="scaffold_2_heading">Rodzaje elementów rusztowania</string>
    <string name="scaffold_4_heading">Położenie FAB</string>
    <string name="column_row_1_1">Funkcje kompozycyjne mogą tworzyć wiele elementów interfejsu. Bez żadnych wskazówek Compose może je ułożyć w niepożądany sposób.\nNa przykład następująca funkcja tworzy dwa teksty bez określania układu:\n</string>
    <string name="column_row_1_2">Po określeniu układu teksty są komponowane w sposób bardziej przewidywalny:</string>
    <string name="column_row_1_3">W wielu przypadkach, do stworzenia różnych układów interfajsu aplikacji, wystarczą funkcje kompozcyjne |Column| i |Row|.</string>
    <string name="column_row_2_1">|Column| i |Row| akceptują wiele funkcji kompozycyjnych jako swoją zawartość.\nMożesz również zagnieżdżać wiele wierszy i kolumn, aby tworzyć bardziej zaawansowane elementy.\n</string>
    <string name="column_row_2_2">Podczas dodawania wielu elementów kompozycyjnych do kontenera przydatna może okazać się funkcja |repeat|:</string>
    <string name="column_row_3_1">Możesz określić sposób ułożenia zawartości wewnątrz kontenera, określając |verticalAlignment| i |horizontalArrangement| dla wierszy oraz |verticalArrangement| i |horizontalAlignment| dla kolumn.\n</string>
    <string name="column_row_3_2">Klasa |Arrangement| umożliwia również dodanie odstępu pomiędzy elementami za pomocą metody |spacedBy|:</string>
    <string name="column_row_expand">Rozszerz</string>
    <string name="column_row_collapse">Zwiń</string>
    <string name="column_row_6_1">Elementy wewnątrz kolumn i wierszy mogą mieć przypisane wagi, aby odpowiednio podzielić dostępną przestrzeń.\nIm większa waga elementu, tym więcej miejsca zajmie.</string>
    <string name="column_row_7_1">Jeśli zawartość nie mieści się w kontenerze, możesz włączyć przewijanie za pomocą modyfikatorów |horizontalScroll| lub |verticalScroll|.</string>
    <string name="column_row_8_1">Jeśli chcesz wyświetlić dużą lub nieznaną liczbę elementów, powinieneś rozważyć użycie leniwych wersji kontenerów: |LazyColumn| i |LazyRow|.\nMogą one znacznie poprawić wydajność aplikacji, poprzez renderowanie tylko tych elementów które są obecnie widoczne.</string>
    <string name="column_row_8_2">Leniwe kontenery nie akceptują bezpośrednio innych elementów kompozycyjnych jako swojej zawartości — należy użyć funkcji |item| lub |items|.</string>
    <string name="column_row_9_1">Kontenery Lazy umożliwiają programowe sterowanie opcją przewijania za pomocą |LazyListState|.\nMoże to być przydatne, jeśli chcesz wyłączyć gesty przewijania lub przewinąć do określonego elementu.\nMetody kontrolujące przewijanie powinny być wywoływane wewnątrz |coroutineScope|.</string>
    <string name="column_row_10_1">Możesz animować zmiany wyświetlanych elementów, używając modyfikatora |animateItem|.\nJeśli wyświetlane elementy są bardziej złożone, rozważ podanie unikalnego klucza dla każdego z nich w funkcji |items|. Dzięki temu Compose może je śledzić i stosować właściwe animacje.</string>
    <string name="box_1_1">|Box| można używać do umieszczania elementów na sobie, umożliwiając przy tym określenie ich ułożenia.</string>
    <string name="box_1_2">Elementy wewnątrz pola mogą używać modyfikatora |align| w celu skonfigurowania swojego wyrównania.</string>
    <string name="box_2_1">Zamiast ustawiać wyrównanie dla każdego elementu osobno, możesz użyć parametru |contentAlignment|, aby zastosować wyrównanie do całej zawartości.</string>
    <string name="box_3_1">Innym zastosowaniem |Box| jest dopasowanie rozmiaru zawartości do rozmiaru kontenera. Możesz to zrobić za pomocą modyfikatora |matchParentSize|.\n</string>
    <string name="grid_1_1">Siatki to kolejny typ leniwych kontenerów. Funkcje kompozycyjne |LazyVerticalGrid| i |LazyHorizontlGrid| ułatwiają wyświetlanie elementów w siatce.\nPodobnie jak |LazyColumn| i |LazyRow|, one również udostępniają funkcje |item| i |items| umożliwiające dodawanie treści.</string>
    <string name="grid_1_2">Podczas tworzenia siatki wymagane jest określenie liczbę kolumn (lub wierszy).</string>
    <string name="grid_2_1">Zamiast ustawiać liczbę kolumn (lub wierszy) możesz ustawić ich rozmiar.\nMożesz sprawić, że będą miały stały rozmiar lub będą adaptacyjne|. Komórki adaptacyjne zajmą co najmniej określoną przestrzeń i podzielą pozostałą część równo.</string>
    <string name="grid_3_1">Tworzenie siatki poziomej jest bardzo podobne do pionowej: wystarczy zastąpić |LazyVerticalGrid| przez |LazyHorizontalGrid| i użyć parametru |rows| zamiast |columns|.</string>
    <string name="grid_4_1">Gird umożliwia zmianę układu treści podobnie jak w przypadku list, z tą różnicą, że w przypadku Gird używane są zarówno |VerticalArrangement|, jak i |HorizontalArrangement|, a nie |Alignment|.</string>
    <string name="grid_5_1">Podobnie jak w przypadku list, możesz animować zmiany w zawartości za pomocą modyfikatora |animateItem| i podać klucz dla każdego elementu.</string>
    <string name="grid_6_1">Używając |LazyGridState| możesz programowo kontrolować pozycję przewijania. W przypadku siatki schodkowej powinieneś użyć |StaggeredGridState|.</string>
    <string name="grid_7_1">Siatki schodkowe umożliwiają wyświetlanie elementów o różnych rozmiarach wzdłuż głównej osi.</string>
    <string name="quiz_column_row_1">Czy można używać zagnieżdżonych kolumn i wierszy?</string>
    <string name="quiz_column_row_1_1">Tak</string>
    <string name="quiz_column_row_1_2">Tak, ale czy możesz użyć maksymalnie 2</string>
    <string name="quiz_column_row_1_3">Nie jest do dozwolone</string>
    <string name="quiz_column_row_2">Jak sprawić, by kolumna była przewijalna?</string>
    <string name="quiz_column_row_2_1">Używając funkcji kompozycyjnej *ScrollableColumn*</string>
    <string name="quiz_column_row_2_2">Stosując modyfikator *verticalScroll*</string>
    <string name="quiz_column_row_2_3">Kolumny i rzędy są domyślnie przewyjalne</string>
    <string name="quiz_column_row_3">Które funkcje kompozycyjne najlepiej nadają się do wyświetlania dużej liczby elementów?</string>
    <string name="quiz_box_1">Jak możesz ustawić pozycję zawartości *Box*-a?</string>
    <string name="quiz_box_1_1">Za pomocą parametru kontenera *contentAlignment*</string>
    <string name="quiz_box_1_2">Za pomocą parametru zawartości *alignment*</string>
    <string name="quiz_box_1_3">Stosując modyfikator *align* na zawartości</string>
    <string name="quiz_box_1_4">Poprzez ustawianie zawartości w bloku *Align*</string>
    <string name="quiz_box_2">Czy *Box* pozwala na dodawanie wielu elementów?</string>
    <string name="quiz_box_2_1">*Box* wspiera tylko jedną wewnętrzną funkcję kompozycyjną</string>
    <string name="quiz_box_2_2">*Box* może zawierać dowolną liczbę elementów składowych</string>
    <string name="quiz_box_2_3">*Box* może zawierać do 3 elementów do złożenia</string>
    <string name="quiz_grid_1">Jak można ustawić zawartość leniwych siatek?</string>
    <string name="quiz_grid_1_1">Umieszczając je bezpośrednio wewnątrz lambdy *content*</string>
    <string name="quiz_grid_1_2">Za pomocą funkcji *item* lub *items*</string>
    <string name="quiz_grid_1_3">Za pomocą funkcji *setContent*</string>
    <string name="quiz_grid_2">Jak sprawić, by *VerticalLazyGrid* było przewijalne?</string>
    <string name="quiz_grid_2_1">Stosując modyfikator *LazyScrollable*</string>
    <string name="quiz_grid_2_2">Ustawiając parametr *scrollable* na *true*</string>
    <string name="quiz_grid_2_3">Leniwe siatki są domyślnie przewijalne</string>
    <string name="quiz_grid_3">Jak możesz dodać odstępy między elementami wewnątrz *LazyVerticalGrid*?</string>
    <string name="quiz_grid_3_1">Za pomocą parametru *itemSpacing*</string>
    <string name="quiz_grid_3_2">Używając *Arrangement.spacedBy* dla parametrów *verticalArrangement* i *horizontalArrangement*</string>
    <string name="quiz_grid_3_3">Poprzez zastosowanie modyfikatora *contentPadding*</string>
    <string name="scaffold_3_fab">Zmień pozycję FAB</string>
    <string name="scaffold_2_top_bar">Pasek górny</string>
    <string name="scaffold_2_bottom_bar">Pasek dolny</string>
    <string name="scaffold_5_snackbar">Wyświetl snackbar</string>
    <string name="scaffold_1_content">Zawartość rusztowania</string>
    <string name="scaffold_3_heading">Kolor zawartości</string>
    <string name="scaffold_1_1">W Jetpack Compose rusztowanie to struktura, która ułatwia tworzenie złożonego interfejsu użytkownika w ujednolicony sposób.\nMa ono modułową strukturę, umożliwiającą wybór części, które najlepiej sprawdzą się w Twojej aplikacji.\n</string>
    <string name="scaffold_2_1">Głównymi elementami rusztowania są górny pasek (Top App Ba), dolny pasek (Bottom App Bar) i FAB (Floating Action Button). Każdy z tych elementów dostępny jest w kilku różnych wersjach.</string>
    <string name="scaffold_3_1">Możesz dostosować domyślne kolory zawartości za pomocą parametrów |containerColor| i |contentColor|.</string>
    <string name="scaffold_4_1">Pozycję FAB można zmienić za pomocą parametru |floatingActionButtonPosition|. Dostępne pozycje to |Start|, |Center|, |End| i |EndOverlay|.</string>
    <string name="scaffold_5_1">|Scaffold| pozwala również na wyświetlanie krótkich wiadomości w snackbarze. Snackbar, w przeciwieństwie do toastów umożliwia na interakcję ze strony użytkownika.</string>
    <string name="scaffold_5_2">Aby użyć snackbaru możesz użyć parametru |snackbarHost| w następujący sposób:</string>
    <string name="scaffold_5_3">Aby wyświetlić wiadomość, możesz użyć metody |showSnackbar|.\nWiadomości na pasku przekąsek mogą mieć różny czas trwania i opcjonalną etykietę akcji.\nMożesz sprawdzić, czy etykieta akcji została kliknięta przez użytkownika, używając wartości zwracanej przez metodę.\nNależy pamiętać, że wyświetlanie wiadomości snackbar jest operacją zawieszającą (suspend).</string>
    <string name="scaffold_3_2">Należy pamiętać, że podczas dodawania zawartości do rusztowania należy używać podanych wartości marginesów:</string>
    <string name="scaffold_5_4">Możesz ukryć bieżącą wiadomość, korzystając z tego sposobu:</string>
    <string name="quiz_scaffold_1">Jakie są główne elementy rusztowania?</string>
    <string name="quiz_scaffold_2">Jaki jest główny cel rusztowania?</string>
    <string name="quiz_scaffold_2_1">Bycie bardziej zaawansowaną alternatywa dla *Box*</string>
    <string name="quiz_scaffold_2_2">Poprawa wydajności interfejsu użytkownika aplikacji</string>
    <string name="quiz_scaffold_2_3">Bycie głównym kontenerem na inne funkcje kompozycyjne</string>
    <string name="quiz_scaffold_3">Jak sprawdzić, czy użytkownik kliknął akcję na wiadomości snackbar?</string>
    <string name="quiz_scaffold_3_1">Sprawdzając pole *wasClicked* hosta snackbaru</string>
    <string name="quiz_scaffold_3_2">Sparwdzając wartość zwróconą przrz metodę *showSnackbar*</string>
    <string name="quiz_scaffold_3_3">Sprawdzając stan *GlobalSnackbarController*</string>
    <string name="quiz_button_1">Czy można wyświetlić dowolną zawartość wewnątrz przycisku?</string>
    <string name="lesson_color_scheme_title">Paleta kolorów</string>
    <string name="color_scheme_1_heading">Tworzenie palety kolorów aplikacji</string>
    <string name="color_scheme_2_heading">Używanie palety kolorów</string>
    <string name="color_scheme_3_heading">Używanie kolorów z modyfikatorami</string>
    <string name="lesson_app_theme">Motywy aplikacji i dynamiczna paleta kolorów</string>
    <string name="app_theme_1_heading">Używanie ciemnego motywu aplikacji</string>
    <string name="app_theme_2_heading">Dynamiczna paleta kolorów</string>
    <string name="app_theme_3_heading">Wyświetlanie od krawędzi do krawędzi</string>
    <string name="grid_2_2">Siatka z komórkami |FixedSize|:</string>
    <string name="grid_2_3">Siatka z komórkami |Adaptive|:</string>
    <string name="app_theme_2_current">Obecny motyw: %1$s</string>
    <string name="use_dynamic_colors">Używaj dynamiczej palety kolorów</string>
    <string name="dynamic_colors">Dynamiczna paleta kolorów</string>
    <string name="app_theme_3_current">Dynamiczne kolory: %1$s</string>
    <string name="material_theme_1_heading">Tworzenie palety kolorów Material Theme</string>
    <string name="material_theme_2_heading">Stosowanie motywu w aplikacji</string>
    <string name="material_theme_3_heading">Używanie palety kolorów</string>
    <string name="material_theme_4_heading">Tworzenie typografii</string>
    <string name="material_theme_5_heading">Używanie typografii</string>
    <string name="material_theme_6_heading">Tworzenie kształtów</string>
    <string name="material_theme_7_heading">Używanie kształtów</string>
    <string name="material_theme_8_heading">Zakres niestandardowego motywu</string>
    <string name="color_scheme_1_1">Możesz utworzyć paletę kolorów dla swojej aplikacji, używając zasobów XML.\nTworzenie palety pozwala na łatwiejsze wykorzystanie kolorów w wielu miejscach i pomaga uczynić wygląd Twojej aplikacji bardziej spójnym.</string>
    <string name="color_scheme_1_2">Przykładowy plik |colors.xml|:</string>
    <string name="color_scheme_1_3">Aby uzyskać dostęp do kolorów z palety możesz użyć funkcji |colorResource|:</string>
    <string name="color_scheme_2_1">Wiele obiektów kompozycyjnych ma zdefiniowane wartości domyślne (np. |CardDefaults|), które są pomocne podczas stosowania palety kolorów.</string>
    <string name="color_scheme_3_1">Jeśli funkcja kompozycyjna nie akceptuje kolorów bezpośrednio, możesz użyć modyfikatora |background| aby ustawić kolor tła.</string>
    <string name="material_theme_1_1">Material theme to bardziej ustandaryzowany sposób tworzenia motywu aplikacji. Podczas tworzenia schematu kolorów poszczególne kolory są nazywane na podstawie ich funkcji, a nie wartości.</string>
    <string name="material_theme_1_2">Po utworzeniu schematu kolorów możesz użyć go w funkcji kompozycyjnej |MaterialTheme|, aby zastosować go do zawartości.</string>
    <string name="material_theme_2_1">Możesz zastosować motyw do całej aplikacji, umieszczając jej układ wewnątrz utworzonej funkcji kompozyjnej |AppTheme|.\nDzięki temu wygląd wszystkich elementów interfejsu będzie spójny z designem aplikacji.</string>
    <string name="material_theme_2_2">Stosowanie motywu do całej aplikacji wewnątrz pliku |MainActivity.kt|:</string>
    <string name="material_theme_3_1">Aby uzyskać dostęp do konkretnych kolorów, możesz użyć obiektu |MaterialTheme.colorScheme|.\nOpisowe nazwy kolorów pomagają zdecydować, który kolor najlepiej pasuje do konkretnej roli w hierarchii UI.</string>
    <string name="material_theme_3_2">Przykładową kombinacją kolorów jest |primaryContaier| z |onPrimaryContainer|. Takie połączenie zapewnia naturalny wygląd oraz odpowiedni kontrast elementów interfejsu.</string>
    <string name="material_theme_1_3">Tworzenie niestandardowych schematów kolorów można znacząco usprawnić za pomocą generatora kolorów Material 3, dostępnego online.</string>
    <string name="material_theme_4_1">|MaterialTheme| można również wykorzystać do określenia typografii aplikacji.</string>
    <string name="material_theme_5_1">Aby wykorzystać utworzone style tekstu możesz skorzystać z obiektu |MaterialTheme.typography|.</string>
    <string name="material_theme_6_1">Kształty elementów kompozycyjnych można również dostosować za pomocą |MaterialTheme|</string>
    <string name="material_theme_7_1">Większość obiektów kompozycyjnych używa określonych kształtów automatycznie. Jeśli chcesz ustawić je ręcznie, możesz użyć obiektu |MaterialTheme.shapes|.</string>
    <string name="material_theme_8_1">Możesz zrezygnować z głównego designu aplikacji, tworząc oddzielny blok |MaterialTheme| z innymi wartościami:</string>
    <string name="app_theme_1_1">Możesz dodać możliwość zmiany motywu aplikacji, tworząc oddzielne schematy kolorów dla trybu jasnego i ciemnego, i następnie decydując, którego użyć w zależności od warunków.</string>
    <string name="app_theme_1_2">Za pomocą funkcji |isSystemInDarkTheme| możesz sprawdzić, czy urządzenie korzysta z ciemnego motywu systemowego.</string>
    <string name="app_theme_2_1">Urządzenia z systemem Android 12 i nowszym mogą korzystać z funkcji dynamicznych kolorów.\nFunkcja ta wykorzystuje specjalny algorytm, który tworzy niestandardowy schemat kolorów na podstawie tapety użytkownika.\nDzięki temu aplikacja może stać się bardziej spersonalizowana i lepiej pasować do motywu systemu.</string>
    <string name="app_theme_2_2">Aby utworzyć dynamiczną paletę kolorów możesz użyć funkcji |dynamic DarkColorScheme| lub |dynamic LightColorScheme|.</string>
    <string name="app_theme_no_e2e">Górny pasek aplikacji z wyłączonym *edge to edge*:\n</string>
    <string name="app_theme_e2e">Górny pasek aplikacji z włączonym *edge to edge*:\n</string>
    <string name="app_theme_3_1">Aplikacje przeznaczone dla zestawu SDK 35 lub nowszego mają automatycznie włączoną funkcję edge-to-edge w systemie Android 15.\nAby włączyć funkcję edge-to-edge w poprzednich wersjach systemu Android, wykonaj następujące czynności:</string>
    <string name="app_theme_3_2">1. Dodaj bibliotekę |androidx.activity| do zależności w pliku |build.gradle|:</string>
    <string name="app_theme_3_3">2. Zaimportuj funkcję |enableEdgeToEdge| i wywołaj ją wewnątrz metody |onCreate| swojej aktywności.</string>
    <string name="quiz_app_theme_1">Której funkcji można użyć do określenia obecnego motywu systemu?</string>
    <string name="quiz_app_theme_2">Od której wersji systemu Android dostępna jest funkcja dynamicznych kolorów?</string>
    <string name="quiz_app_theme_3">Jak można włączyć wyświetlanie *edge-to-edge*?</string>
    <string name="quiz_app_theme_3_1">Używając funkcji *setFullScreen(true)*</string>
    <string name="quiz_app_theme_3_2">Ustawiając *edgeToEdge* na *true* w manifeście aplikacji</string>
    <string name="quiz_app_theme_3_3">Używając funkcji *enableEdgeToEdge*</string>
    <string name="quiz_color_scheme_1">W jaki sposób można uzyskać dostęp do kolorów zdefiniowanych w plikach zasobów?</string>
    <string name="quiz_color_scheme_1_1">Używając *R.color* bezpośrednio</string>
    <string name="quiz_color_scheme_1_2">Za pomocą funkcji *colorResource*</string>
    <string name="quiz_color_scheme_1_3">Kopiując wartość HEX koloru w pliku zasobów</string>
    <string name="quiz_color_scheme_2">Jak można zmienić kolor obiektu kompozycyjnego, który nie akceptuje żadnych parametrów koloru?</string>
    <string name="quiz_color_scheme_2_1">Umieszczając go wewnątrz bloku *Color*</string>
    <string name="quiz_color_scheme_2_2">Stosując modyfikator *background*</string>
    <string name="quiz_color_scheme_2_3">Nie jest to możliwe</string>
    <string name="quiz_material_theme_1">Kolory w motywie Material Theme są nazwane na podstawie:</string>
    <string name="quiz_material_theme_1_1">Ich wartości RGB</string>
    <string name="quiz_material_theme_1_2">Ich funkcji</string>
    <string name="quiz_material_theme_1_3">Standardowych nazw kodowych</string>
    <string name="quiz_material_theme_2">Co oznacza rozmiar kształtu Material Theme?</string>
    <string name="quiz_material_theme_2_1">Rozmiar elementu kompozycyjnego</string>
    <string name="quiz_material_theme_2_2">Wewnętrzny margines elementu kompozycyjnego</string>
    <string name="quiz_material_theme_2_3">Promień narożnika elementu kompozycyjnego</string>
    <string name="quiz_material_theme_3">Czy elementy kompozycyjne wewnątrz *MaterialTheme* można dodatkowo dostosowywać?</string>
    <string name="quiz_material_theme_3_1">Nie</string>
    <string name="quiz_material_theme_3_2">Tak, używając adnotacji *@Override* w stylu</string>
    <string name="quiz_material_theme_3_3">Tak, poprzez utworzenie nowego bloku *MaterialTheme*</string>
    <string name="lesson_remember_title">Zapamiętywanie stanu</string>
    <string name="lesson_view_model_title">Używanie viewModelu</string>
    <string name="lesson_persistent_title">Trwały stan</string>
    <string name="lesson_lifecycle_title">Cykl życia elementów kompozycyjnych</string>
    <string name="remember_1_heading">Obiekty stanu i funkcja remember</string>
    <string name="remember_2_heading">Aktualizowanie UI</string>
    <string name="remember_3_heading">Wynoszenie stanu (hoisting)</string>
    <string name="remember_4_heading">Przywracanie stanu</string>
    <string name="remember_5_heading">Unieważnianie stanu</string>
    <string name="lifecycle_1_heading">Kompozycja i rekompozycja</string>
    <string name="lifecycle_1_1">Kiedy Jetpack Compose uruchamia Twoje kompozycje po raz pierwszy, podczas #pierwszej kompozycji#, będzie śledził wywoływane obiekty, które opisują interfejs użytkownika w kompozycji.\nGdy stan aplikacji ulega zmianie, Jetpack Compose rozpoczyna #rekompozycję#.\nRekompozycja wywołuje ponownie funkcje kompozycyjnem które mogły ulec zmianie na skutek zmiany stanu, a następnie aktualizuje kompozycję, aby odzwierciedlić zmiany.</string>
    <string name="lifecycle_1_2">*Kompozycja* może być utworzona tylko przez początkową kompozycję, a następnie aktualizowana przez rekompozycję.\nJedynym sposobem na modyfikację *Kompozycji* jest rekompozycja.</string>
    <string name="lifecycle_1_label">Diagram cyklu życia elementu kompozycyjnego</string>
    <string name="lifecycle_1_3">Rekompozycja jest zwykle wyzwalana przez zmianę obiektu |State&lt;T&gt;|. Compose śledzi takie obiekty i uruchamia wszystkie funkcje kompozycyjne, które odczytują zmieniony obiekt stanu.</string>
    <string name="lifecycle_2_heading">Instancje elementów kompozycyjnych</string>
    <string name="lifecycle_2_1">Instancja elementu kompozycyjnego w kompozycji jest identyfikowana przez jego *miejsce wywołania* (call site). Kompilator Compose traktuje każde miejsce wyłowania jako unikalne.\nWywołanie obiektów composable z wielu miejsc spowoduje utworzenie wielu wystąpień obiektów composable w kompozycji.</string>
    <string name="lifecycle_2_2">Jeśli podczas rekompozycji funkcja kompozycyjna wywołuje inne funkcje kompozycyjne niż podczas poprzedniej kompozycji, Compose zidentyfikuje, które funkcje zostały wywołane, a które nie.\nW przypadku gdy funkcja została wywołana w obu kompozycjach, Compose uniknie rekompozycji, jeśli jej dane wejściowe nie uległy zmianie.</string>
    <string name="lifecycle_3_heading">Wiele elementów kompozycyjnych w jednym miejscu wywołania</string>
    <string name="lifecycle_3_1">Podczas wielokrotnego wywoływania funkcji kompozycyjnej z tego samego miejsca, Compose nie dysponuje żadnymi informacjami pozwalającymi jednoznacznie zidentyfikować każdy obiekt kompozycyjny, dlatego oprócz miejsca wywołania używana jest kolejność wykonywania, aby zachować odrębność wystąpień.</string>
    <string name="lifecycle_3_2">W powyższym przykładzie Compose używa kolejności wykonywania oprócz miejsca wywołania, aby zachować odrębne wystąpienia w kompoizycji.\nJeśli nowy |user| zostanie dodany na #dole# listy, Compose może ponownie użyć wystąpień obecnych w kompozycji.</string>
    <string name="lifecycle_3_3">Jeśli jednak parametr |users| ulegnie zmianie poprzez dodanie elementów na #szczyt# lub do #środka# listy, usunięcie ich lub zmianę ich kolejności, spowoduje to rekompozycję wszystkich wywołań |UserCard|, których parametr wejściowy zmienił pozycję na liście.\nPonadto, jeśli kompozycja zostanie zrekomponowana, wszelkie trwające operacje (takie jak pobieranie obrazu) zostaną anulowane i uruchomione ponownie.</string>
    <string name="lifecycle_4_heading">Pomijanie rekompozycji</string>
    <string name="lifecycle_4_1">Możesz pomóc Compose w identyfikowaniu elementów kompozycyjnych umieszczając je w funkcji kompozycyjnej |key|. Wartość |key| nie musi być #globalnie# unikatowa, musi być unikalna tylko dla bieżącego miejsca wywołania.</string>
    <string name="remember_1_1">W Jetpack Compose stan interfejsu użytkownika reprezentowany jest za pomocą obserwowalnych typów |State|. Tworząc obiekt stanu wewnątrz funkcji kompozycyjnej, należy umieścić go w funkcji |remember|.\nFunkcja |remember| przechowuje wynik obliczeń podczas początkowej kompozycji i ponownie go wykorzystuje później podczas rekompozycji.</string>
    <string name="remember_1_2">Dostępne są trzy sposoby tworzenia obiektu |MutableState| w funkcji kompozycyjnej:</string>
    <string name="remember_1_3">Te deklaracje są równoważne. Powinieneś wybrać tę, która jest dla Ciebie najłatwiejsza do odczytania.\nSkładnia delegata |by| wymaga następujących importów:</string>
    <string name="remember_2_1">Obiekty |State| są odpowiedzialne za wywoływanie rekompozycji i aktualizowanie interfejsu użytkownika. \nPomimo tego, że funkcja |remember| akceptuje dowolne parametry, tylko modyfikacja obiektów stanu spowoduje zmianę interfejsu użytkownika.</string>
    <string name="remember_2_2">W tym przykładzie oba przyciski mają identyczną lambdę |onClick|. Można zauważyć, że przycisk *CountInt* nie aktualizuje się po kliknięciu.</string>
    <string name="remember_3_1">Obiekt composable, który używa |remember| do przechowywania obiektu, tworzy stan wewnętrzny, co powoduje, że funkcja kompozycyjna posiada #stan#.\nFunkcje kompozycyjne ze stanem mogą być łatwiejsze w użyciu, ale często są mniej elastyczne i oferują mniej kontroli.</string>
    <string name="remember_3_2">Możesz zmienić stanową funkcję kompozycyjną na bezstanową za pomocą *state hoisting*. Polega to na zastąpieniu zmiennej stanu dwoma parametrami: jednym podającym bieżącą wartość i drugim, będącym wywołaniem zwrotnym w celu żądania zmiany wartości.</string>
    <string name="remember_3_3">Stan wyniesiony w ten sposób ma kilka ważnych właściwości:</string>
    <string name="remember_3_4">*Jedno źródło prawdy*: Przenoszenie stanu zamiast jego duplikowania pozwala uniknąć wielu błędów.</string>
    <string name="remember_3_5">*Hermetyczny*: Tylko obiekty kompozycyjne ze stanem mogą modyfikować swój stan wewnętrzny.</string>
    <string name="remember_3_6">*Dostępny*: Wyniesiony stan można udostępniać wielu funkcjom kompozycyjnym.</string>
    <string name="remember_4_1">Funkcja |rememberSaveable| pozwala zapamiętać stan nie tylko podczas rekompozycji, ale także podczas odtwarzania aktywności lub procesu.\nDzieje się tak, na przykład, gdy ekran jest obracany lub gdy zmienia się motyw systemu.</string>
    <string name="remember_4_2">Pierwsze pole tekstowe utraci swoją zawartość po obróceniu ekranu, natomiast drugie ją zachowa.</string>
    <string name="remember_5_1">Możesz ponownie wyzwolić obliczenia zapamiętywania, podając parametry kluczy dla funkcji |remember| i |rememberSaveable|. Gdy którykolwiek z kluczy ulegnie zmianie, funkcje zapomną wartości swojego stanu i obliczą ją ponownie.</string>
    <string name="quiz_lifecycle_1">W jaki sposób można modyfikować *Kompozycję*?</string>
    <string name="quiz_lifecycle_1_1">Poprzez użycie dowolnej funkcji kompozycyjnej</string>
    <string name="quiz_lifecycle_1_2">Przez wywołanie rekompozycji</string>
    <string name="quiz_lifecycle_1_3">Przez utworzenie nowej *Kompozycja*, która zastępuje starą</string>
    <string name="quiz_lifecycle_2">W jaki sposób Compose identyfikuje instancje elementów kompozycyjnych?</string>
    <string name="quiz_lifecycle_2_1">Tylko po miejscu wywołania</string>
    <string name="quiz_lifecycle_2_2">Po ich parametrach wejściowych</string>
    <string name="quiz_lifecycle_2_3">Po miejscu oraz kolejności wywołania</string>
    <string name="quiz_lifecycle_3">Podczas rekompozycji, które funkcje kompozycyjne są ponownie wywoływane?</string>
    <string name="quiz_lifecycle_3_1">Wszystkie</string>
    <string name="quiz_lifecycle_3_2">Te, których parametry wejściowe mogły ulec zmianie</string>
    <string name="quiz_lifecycle_3_3">Tylko te, które zwracają wartość *Unit*</string>
    <string name="quiz_remember_1">Jaki jest zalecany sposób tworzenia obiektu stanu wewnątrz funkcji kompozycyjnej?</string>
    <string name="quiz_remember_1_2">Tworzenie *MutableStateOf* wewnątrz *remember*</string>
    <string name="quiz_remember_1_1">Używanie *remember* do zapisywania dowolnej wartości</string>
    <string name="quiz_remember_1_3">Korzystanie z funkcji *createState*</string>
    <string name="quiz_remember_2">Jak można zmienić stanową funkcję kompozycyjną na bezstanową?</string>
    <string name="quiz_remember_2_1">Poprzrz nie używanie funkcji *remember*</string>
    <string name="quiz_remember_2_2">Przechowując cały stan w oddzielnej klasie</string>
    <string name="quiz_remember_2_3">Korzystając ze schematu *wyoszenia stanu*</string>
    <string name="quiz_remember_3">Jak można zachować stan pomiędzy *Kompozycjami*?</string>
    <string name="quiz_remember_3_1">Poprzez podanie parametru *key* do funkcji *remember*</string>
    <string name="quiz_remember_3_2">Używając funkcji *rememberSaveable*</string>
    <string name="quiz_remember_3_3">Korzystając z *data class* do przechowywania stanu</string>
    <string name="remember_4_3">Ponieważ |rememberSaveable| przechowuje dane w |Bundle|, zapisywanie złożonych typów jest niceo bardziej skomplikowane, niż w przypadku użycia |remember|.\nNajprostszym rozwiązaniem jest adnotacja typu za pomocą |@Parcelize|. Inną opcją jest użycie |mapSaver| do zdefiniowania własnych reguł konwersji obiektu na zestaw wartości, które można zapisać w |Bundle|.</string>
    <string name="lesson_bottom_sheet_title">Panel dolny</string>
    <string name="bottom_sheet_display">Wyświetl panel dolny</string>
    <string name="bottom_sheet_hide">Ukryj panel dolny</string>
    <string name="bottom_sheet_1_content">Kliknij poza panelem lub przesuń w doł, aby go zamknąć</string>
    <string name="bottom_sheet_2_content">Przesuń w górę, aby rozwinąć panel. Przesuń w dół, aby zamknąć.</string>
    <string name="bottom_sheet_1_heading">Wyświetlanie panelu dolnego</string>
    <string name="bottom_sheet_2_heading">Częściowe rozwijanie panelu</string>
    <string name="bottom_sheet_3_heading">Określanie szerokości i uchwytu</string>
    <string name="bottom_sheet_4_heading">Dostosowywanie wyglądu</string>
    <string name="viewmodel_1_heading">Tworzenie viewModelu</string>
    <string name="viewmodel_2_heading">Udostępnianie stanu UI</string>
    <string name="viewmodel_3_heading">Używanie viewModelu w funkcjach kompozycyjnych</string>
    <string name="viewmodel_4_heading">Operacje asynchroniczne</string>
    <string name="viewmodel_5_heading">Najlepsze praktyki</string>
    <string name="persistent_1_heading">Zapisywanie danych w preferencjach</string>
    <string name="persistent_2_heading">Przechowywanie i pobieranie danych</string>
    <string name="persistent_3_heading">Łączenie z viewModelem</string>
    <string name="persistent_4_heading">Używanie zapisanych danych w funkcjach kompozycyjnych</string>
    <string name="biometrics_auth_failed">Uwierzytelnianie nie powiodło się</string>
    <string name="biometrics_not_set">Uwierzytelnianie nie zostało ustawione</string>
    <string name="biometrics_auth_success">Uwierzytelnianie powiodło się</string>
    <string name="biometrics_feature_unavailable">Funkcja niedostępna</string>
    <string name="biometrics_hardware_unavailable">Sprzęt niedostępny</string>
    <string name="lesson_biometrics_title">Biometryka</string>
    <string name="lesson_notification_title">Wysyłanie powiadiomień</string>
    <string name="lesson_pager_title">Pager</string>
    <string name="lesson_nav_ctr_host_title">Kontroller i host nawigacji</string>
    <string name="lesson_bottom_navbar_title">Dolny pasek nawigacji</string>
    <string name="lesson_back_handler_title">Obługa cofania</string>
    <string name="lesson_navigation_suite_title">Zestaw nawigacyjny</string>
    <string name="lesson_animated_visibility_title">Animowanie interfejsu</string>
    <string name="lesson_animate_values_title">Animowanie wartości</string>
    <string name="lesson_nav_transitions_title">Przejścia nawigacji</string>
    <string name="navigation_1_heading">Tworzenie kontrolera nawigacji</string>
    <string name="navigation_2_heading">Graf nawigacji</string>
    <string name="navigation_3_heading">Nawigowanie pomiędzy ekranami</string>
    <string name="navigation_4_heading">Przekazywanie danych</string>
    <string name="navigation_5_heading">Głębokie linki</string>
    <string name="animation_toggle">Przełącz</string>
    <string name="animating_values_1_heading">Animowianie stanu</string>
    <string name="animating_values_2_heading">Animowanie DP</string>
    <string name="animating_values_3_heading">Właściwości animacji</string>
    <string name="animating_values_4_heading">Animowanie wielu wartości</string>
    <string name="animating_values_5_heading">Nieskończona animacja</string>
    <string name="animated_visibility_click">Kliknij, aby zmienić widoczność</string>
    <string name="animated_visibility_1_heading">Animowanie widoczności</string>
    <string name="animated_visibility_2_heading">Rodzaje przejść</string>
    <string name="animated_visibility_3_heading">Łączenie przejść</string>
    <string name="animated_visibility_4_heading">Animowanie wewnętrznej zawartości</string>
    <string name="animated_visibility_5_heading">Animowanie zmian zawartości</string>
    <string name="pager_scroll_forward">Przewiń do przodu</string>
    <string name="pager_scroll_backward">Przewiń wstecz</string>
    <string name="pager_current_page_snackbar">Obecna strona</string>
    <string name="pager_1_heading">Pionowy i poziomy pager</string>
    <string name="pager_2_heading">Leniwy układ</string>
    <string name="pager_3_heading">Kontrolowanie pozycji</string>
    <string name="pager_4_heading">Nasłuchwanie zmian stron</string>
    <string name="pager_5_heading">Wskaźnik strony</string>
    <string name="pager_6_heading">Zmienianie rozmarów stron</string>

</resources>
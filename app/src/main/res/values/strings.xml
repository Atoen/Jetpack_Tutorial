<resources>

    <string name="regular_text" translatable="false">This is a regular text without monospace</string>
    <string name="formatted_text" translatable="false">This text contains |monospace| and *bold* formatting</string>

    <string name="app_name">Jetpack Tutorial</string>
    <string name="back_again_to_close">Back again to close the app</string>
    <string name="settings">Settings</string>
    <string name="select_app_language">Select app language</string>
    <string name="polish">Polish</string>
    <string name="english">English</string>

    <string name="completed">Completed</string>
    <string name="completed_percent">Completed %1$d%%</string>

    <string name="app_theme">App theme</string>
    <string name="theme_auto">Auto</string>
    <string name="theme_light">Light</string>
    <string name="theme_dark">Dark</string>

    <!-- Groups -->
    <string name="course_getting_started_title">Getting Started with Jetpack Compose</string>
    <string name="course_layout_title">UI layout</string>
    <string name="course_theming_styling">Styling the UI</string>
    <string name="course_getting_started_description">Learn the basics of Jetpack Compose, including setting up your environment and creating your first composable.</string>
    <string name="course_layout_description">Dive into Compose layouts, theming, and styling your app.</string>
    <string name="curse_state_navigation_description">Manage state effectively and navigate between screens in your Compose app.</string>
    <string name="course_advanced_description">Explore advanced Jetpack Compose topics like animations, custom layouts, and performance optimization.</string>
    <string name="TODO" translatable="false">!!TODO!!</string>
    <string name="popup_continue">Continue</string>
    <string name="swipe_to_dismiss">Swipe to dismiss</string>
    <string name="lesson_finished">Lesson completed</string>

    <!-- Lessons -->
    <plurals name="lesson_pages">
        <item quantity="one">%d page</item>
        <item quantity="other">%d pages</item>
    </plurals>

    <plurals name="incorrect_answers">
        <item quantity="one">incorrect answer.</item>
        <item quantity="other">incorrect answers</item>
    </plurals>

    <string name="lesson_introduction_title">What is Jetpack Compose?</string>
    <string name="setting_up_environment_title">Setting up environment</string>
    <string name="creating_first_component_title">Creating first component</string>
    <string name="completed_n_of">Completed %1$d of %2$d lessons</string>
    <string name="course_compose_basics_title">Jetpack Compose Basics</string>
    <string name="course_state_lifecycle">State and lifecycle</string>
    <string name="course_navigation">Navigation</string>
    <string name="course_animations">Animations</string>
    <string name="course_advanced">Advanced</string>
    <string name="clear_all_progress">Clear all progress</string>
    <string name="dialog_cancel">Cancel</string>
    <string name="dialog_clear_progress">Clear progress</string>
    <string name="dialog_clear_title">Clear all progress</string>
    <string name="dialog_clear_text">Are you sure you want to reset your progress for all courses? This action cannot be undone.</string>
    <string name="popup_start">Get started</string>
    <string name="enabled">Enabled</string>
    <string name="disabled">Disabled</string>
    <string name="select_app_theme">Select app theme</string>
    <string name="app_language">App language</string>
    <string name="lesson_popup">Next lesson</string>
    <string name="lesson_popup_options">Display next lesson</string>
    <string name="lesson_text_title">Displaying text</string>
    <string name="text_8_heading">Configure text layout</string>
    <string name="font_small">Small</string>
    <string name="font_medium">Medium</string>
    <string name="font_big">Big</string>
    <string name="code_listing_font">Code listing font</string>
    <string name="select_listing_font">Select code listing font</string>
    <string name="text_1_heading">Displaying basic text</string>
    <string name="text_1_1">The simplest way to display text is to use the |Text| composable.\nIt has one required parameter: the string to display.</string>
    <string name="text_1_2">This code will display the following text:</string>
    <string name="text_2_heading">Styling text</string>
    <string name="text_2_1">The |Text| composable has multiple optional parameters that you can use to change its content appearance.</string>
    <string name="text_2_2">Change text color:</string>
    <string name="text_2_3">Change text size:</string>
    <string name="text_4_heading">Modifying font</string>
    <string name="text_4_1">Make text italic:</string>
    <string name="text_4_2">Make text bold:</string>
    <string name="text_4_3">Jetpack Compose also provides other font weights: |Thin|, |ExtraLight|, |Light|, |Normal|, |Medium|, |SemiBold|, |ExtraBold|, and |Black|.\nYou can also create custom font weight by passing an Int to the constructor.</string>
    <string name="text_6_heading">Advanced styling</string>
    <string name="text_6_1">You can add shadow to the text by creating a new |TextStyle| and specifying the color, offset, and blur radius of the shadow.</string>
    <string name="text_5_heading">Text decorations</string>
    <string name="text_5_1">Draw a horizontal line over the text:</string>
    <string name="text_5_2">You can combine text decoration using the |TextDecoration.combine| function or the addition operator:</string>
    <string name="text_7_heading">Advanced styling - multiple styles</string>
    <string name="text_7_1">You can combine different styles in one |Text| using the |AnnotatedString| class. The helper function |buildAnnotatedString| allows you to easily append text fragments with different styles.</string>
    <string name="text_9_heading">Display text from resource</string>
    <string name="text_9_1">The recommended approach to displaying text is using string resources instead of hardcoding the values in code.\nThis allows for easier and less error-prone reuse of the same texts as well as preparing your app for internationalization.</string>
    <string name="hello_world">Hello, World! (in English)</string>
    <string name="text_8_1">You can limit the number of lines displayed for long texts:</string>
    <string name="text_8_2">Additionally, you can also indicate that the text is overflowing:</string>
    <string name="text_3_heading">Changing font</string>
    <string name="text_3_1">Use monospace font:</string>
    <string name="text_3_2">Jetpack Compose also provides other fonts: |Default|, |SansSerif|, |Serif|, and |Cursive|. You can also use your own custom font after importing it into the project.</string>
    <string name="button_1_heading">Creating basic button</string>
    <string name="lesson_button_title">Buttons</string>
    <string name="button_1_1">To create a button, you can use the |Button| composable function.\nIt has two required parameters: the content to display and the callback to invoke when the user clicks the button.</string>
    <string name="button_2_heading">Performing action on click</string>
    <string name="button_2_1">To perform some action when the user clicks the button, you can pass a function to the |onClick| callback.</string>
    <string name="button_2_2">The |remember| and |mutableIntStateOf| will be explained in later lessons.</string>
    <string name="button_3_heading">Types of buttons</string>
    <string name="button_3_1">Jetpack Compose provides 5 predefined types of buttons: filled (default), tonal, outlined, elevated and text.\nYou can one which will fit your app style and its expected behaviour.</string>
    <string name="button_4_heading">Icon buttons</string>
    <string name="button_4_1">Another variant of button is the icon button. It usually contains a single icon (but it can also be something different).\nIt comes in 3 variants: default, filled and outlined.</string>
    <string name="button_5_heading">Toggle buttons</string>
    <string name="button_5_1">Icon buttons can also be used as toggles to cycle between checked and unchecked state on each click.\nThey have two required parameters: the current check state (boolean) and function to invoke when the state changes.\nIcon toggle buttons come in 3 variations: filled, tonal and outlined.</string>
    <string name="button_1_2">You can disable button by setting the |enabled|parameter to false.</string>
    <string name="button_6_heading">Customizing colors</string>
    <string name="button_6_1">You can change the colors of a button by creating new |ButtonColors| and passing it to the composable:</string>
    <string name="button_7_heading">Modifying shape</string>
    <string name="button_7_1">You can change the shape of a button by providing custom one.\nPadding of the content can also be specified by the |contentPadding| parameter.</string>
    <string name="button_8_heading">Border</string>
    <string name="button_8_1">You can add borders to button using the |border| parameter.\nBorder can have solid color or a gradient.</string>
    <string name="lesson_toast_title">Toast messages</string>
    <string name="toast_requires_newer_api">This preview requires API level 30 (Android 11) to work.</string>
    <string name="toast_1_heading">Displaying toast messages</string>
    <string name="toast_2_heading">Adding callbacks</string>
    <string name="toast_3_heading">Cancelling messages</string>
    <string name="lesson_text_field_title">Text field</string>
    <string name="text_field_1_heading">Creating text field</string>
    <string name="text_field_2_heading">Limiting number of lines</string>
    <string name="text_field_3_heading">Disabled and readonly fields</string>
    <string name="text_field_4_heading">Decorating text fields</string>
    <string name="text_field_5_heading">Adding prefix and suffix</string>
    <string name="text_field_6_heading">Visual transformations</string>
    <string name="text_field_7_heading">Custom input</string>
    <string name="text_field_8_heading">IME action</string>
    <string name="text_field_9_heading">Customizing appearance</string>
    <string name="lesson_image_title">Images</string>
    <string name="image_1_heading">Displaying images</string>
    <string name="image_2_heading">Vector graphics</string>
    <string name="image_3_heading">Modifying alpha value</string>
    <string name="image_4_heading">Applying color filter</string>
    <string name="image_5_heading">Tinting</string>
    <string name="image_6_heading">Content scaling</string>
    <string name="lesson_card_title">Cards</string>
    <string name="card_1_heading">Creating card</string>
    <string name="card_2_heading">Card types</string>
    <string name="card_3_heading">Customizing appearance</string>
    <string name="lesson_modifier_title">Using modifiers</string>
    <string name="lorem_ipsum" translatable="false">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque in vulputate mi. Interdum et malesuada fames ac ante ipsum primis in faucibus. Vivamus id velit eget velit blandit vestibulum non sit amet leo. Ut condimentum felis ut ipsum convallis, non cursus lorem pellentesque. Nulla blandit tellus a ipsum aliquam commodo id vitae dolor. Donec cursus consectetur mi ut ornare. Maecenas iaculis metus varius sodales porttitor. In et consequat elit, quis auctor odio. Donec vel dolor et nulla accumsan hendrerit.</string>
    <string name="modifier_1_heading">Applying modifier</string>
    <string name="modifier_2_heading">Order matters</string>
    <string name="modifier_3_heading">Changing size</string>
    <string name="modifier_4_heading">Adding padding</string>
    <string name="modifier_5_heading">Scrolling content</string>
    <string name="modifier_6_heading">Making elements clickable</string>
    <string name="modifier_7_heading">Dragging</string>
    <string name="modifier_8_heading">Animating content size</string>
    <string name="modifier_9_heading">Blurring</string>
    <string name="modifier_10_heading">Clipping shapes</string>
    <string name="modifier_12_heading">Conditional modifier</string>
    <string name="modifier_13_heading">Reusing modifier</string>
    <string name="modifier_11_heading">Accessibility</string>
    <string name="modifier_1_1">Modifiers allow you to decorate or change behaviour of a composable.\nAll of previously described composables have optional parameter: the modifier.</string>
    <string name="modifier_2_1">The order of applied modifier is significant. Each function makes changes to the modifiers returned by the previous function, which results in the sequence affecting the final result.</string>
    <string name="modifier_2_2">In the first example the red background is visibly smaller than in the second, because it is applied after the padding, which limits the space for the following modifiers.</string>
    <string name="modifier_3_1">You can change the size of composables by applying the |size|, |height| or |width| modifiers.\nYou can also fill the whole (possibly partially) space by using the |fillMaxSize|, |fillMaxWidth| or |fillMaxHeight|.</string>
    <string name="modifier_4_1">You can add margins with the |padding| modifier.\nIt can be used to set the same padding on all sides, on horizontal and vertical, or different one on each side.</string>
    <string name="modifier_5_1">If the content doesn\'t, you can enable scrolling of the container.\nModifiers |verticalScroll| and |horizontalScroll| enable scrolling content in corresponding directions.\nYou also need to pass the state of the scroll to these modifiers, usually in the form of |rememberScrollState()| function.</string>
    <string name="modifier_6_1">Any composable can become clickable with the |clickable| modifier.\nYou need to pass function to invoke on each click, similar to buttons.</string>
    <string name="modifier_6_2">It is also possible to invoke different actions on double and long click.\nYou can achieve this by using the |combinedClickable| modifier.</string>
    <string name="modifier_7_1">Composables can also be draggable, by using the |draggable| and |offset| modifiers.\nTo make the dragging work in both axis, you can use the |pointerInput| modifier instead of |draggable| and manually modify the offset in both axis.</string>
    <string name="modifier_8_1">When the content can change its size, you can use |animateContentSize| modifier to allow for a smooth transition.</string>
    <string name="modifier_9_1">You can blur composable with the |blur| modifier.\nIt requires specifying the blur radius and optionally, how to treat the edges of the blur area.</string>
    <string name="modifier_10_1">You can clip content to a specified shape with the |clip| modifier.\nYou can achieve more complex shapes by applying multiple |clip| modifiers.</string>
    <string name="modifier_11_1">You can add accessibility information to your interface by using |semantics| modifier.\nIt can specify the role of particular element and describe it state for accessibility services to use.</string>
    <string name="modifier_12_1">Modifiers can be conditionally applied by using the |Modifier.then| modifier function.</string>
    <string name="modifier_13_1">Modifiers are regular Kotlin objects - you can create one and reuse it in multiple places later.</string>
    <string name="text_field_1_1">Text fields allow users to enter text. To create one you can use composable |TextField|.\nIt has two required parameters: currently displayed text and function invoked on change of inputted value.</string>
    <string name="text_field_1_2">You can add placeholder to display when the inputted value is empty with the |placeholder|. parameter.</string>
    <string name="text_field_2_1">You can limit the text field to only one line by setting the |singleLine| parameter to true.\nYou can also change the minimum and maximum number of visible lines with |minLines| and |maxLines|.</string>
    <string name="text_field_3_1">Parameters |enabled| and |readOnly| can be used to disable the text field and disallow text modifications respectively.</string>
    <string name="text_field_4_1">You can add more visual information to the text field such as icons and labels using |label|, |supportingText|, |leadingIcon| and |trailingIcon| parameters.</string>
    <string name="text_field_5_1">You can also add |prefix| and |suffix| to display around the entered text.</string>
    <string name="text_field_6_1">Text can be transformed visually with the |visualTransformation| parameter. This can be useful, for example, when entering passwords or postal codes.\nJetpack Compose provides ready visual transformation for passwords: |PasswordVisualTransformation|.</string>
    <string name="text_field_6_2">It is possible to create custom visual transformation. The |CustomVisualTransformation| replaces visible letters with numbers 0–9 based on their position.\nNote that the actual text value is unchanged; it still contains exactly what the user entered.</string>
    <string name="text_field_7_1">You can modify the text field to display different keyboard types to the user with the |keyboardOptions| parameter.\nTo make sure that the entered text contains only allowed symbols (e.g. numbers), you can filter the entered text in the |onValueChanged| callback.</string>
    <string name="text_field_8_1">You can change the IME action that is displayed on the keyboard, by creating instance of |KeyboardOptions| with specified IME action, and passing it to the composable.</string>
    <string name="text_field_9_1">You can change the appearance of the text field by passing custom |TextFieldColors| and |TextStyle| to the composable.</string>
    <string name="image_1_1">To display an image you can use |Image| composable.\nIt has two required parameters: the painter that is responsible for drawing the image, usually |painterResource|, and |contentDescription| used by accessibility services.\n|Image| can display png, jpg and webp images.</string>
    <string name="image_2_1">|Image| composable can also display vector graphics.\nThe file describing the graphic should be in xml format.</string>
    <string name="image_3_1">You can modify the alpha value of the displayed image using the |alpha| parameter.</string>
    <string name="image_4_1">Parameter |colorFilter| allows for modifying the color values of each pixel in the image.\nYou can use it to change saturation, shift hue or manually adjust the values.</string>
    <string name="image_5_1">You can also tint images using the |colorFilter| parameter.\nThere are multiple color blend modes available, each resulting in different effects.</string>
    <string name="image_6_1">You can change how an image is scaled inside it bounds using the |contentScale| parameter.\nIf you don\'t specify this parameter, |ContentScale.Fit| will be used as default.</string>
    <string name="card_1_1">Cards acts as a containers for application\'s UI.\nCards typically present single coherent piece of content like a news story in a news app or a message in a communicator app.</string>
    <string name="card_1_2">To create a card you can use the |Card| composable. It has one required parameter: the content to display.</string>
    <string name="card_1_3">Card can be made clickable by providing function to the |onClick| callback parameter.</string>
    <string name="card_2_1">Jetpack Compose provides other variants of the cards: the |ElevatedCard| and |OutlinedCard|.</string>
    <string name="card_3_1">You can customize the colors, shape and border of the card by providing custom values to the |colors|, |shape| and |border| parameters.</string>
    <string name="toast_1_1">A toast is a small popup message that provides feedback about an operation.\nIt takes small amount of space and disappears automatically after a timeout.</string>
    <string name="toast_1_2">To show the toast you first need to instantiate a Toast object.\nYou can do this using |Toast.makeText| method, which takes the following parameters: the |Context| associated with the message, the text to display and the duration of the toast.\nIn Jetpack compose, the context can be easily accessed using the |LocalContext.current| composable.\nAfter creating the toast object, you can use |show| method on it to display it on screen.</string>
    <string name="toast_2_1">You can add callbacks to the toast to know when it is shown and hidden.\nTo do this you can create an object inheriting from |Toast.Callback| and register it using the |addCallback| method.</string>
    <string name="toast_3_1">You can limit the time the toast is visible by calling the |cancel| method to hide it early.</string>

    <string name="quiz_text_1">Which Composable is used to display text in Jetpack Compose?</string>
    <string name="quiz_text_1_1" translatable="false">*Text*</string>
    <string name="quiz_text_1_2" translatable="false">*Label*</string>
    <string name="quiz_text_1_3" translatable="false">*Paragraph*</string>

    <string name="quiz_text_2">How can you change the font size of Text in Jetpack Compose?</string>
    <string name="quiz_text_2_1">Applying the *FontModifier* to the text</string>
    <string name="quiz_text_2_2">Using the *fontSize* parameter</string>
    <string name="quiz_text_2_3">The font size cannot be changed</string>

    <string name="quiz_text_3">Which parameter would you use to change the color of Text?</string>
    <string name="quiz_text_3_1" translatable="false">*fontColor*</string>
    <string name="quiz_text_3_2" translatable="false">*tint*</string>
    <string name="quiz_text_3_3" translatable="false">*color*</string>
    <string name="quiz_question_n_of">Question %1$d of %2$d</string>
    <string name="quiz_check">Check</string>
    <string name="lesson_more_quiz">Go to quiz</string>
    <string name="lesson_more_challenge">Go to challenge</string>
    <string name="code_challenge">Code challenge</string>
    <string name="start_quiz">Start quiz</string>
    <string name="quiz_finished">Quiz finished</string>
    <string name="quiz_answered_correctly_n_of">You answered correctly %1$d out of %2$d questions.</string>
    <string name="quiz_restart">Restart quiz</string>
    <string name="quiz_continue">Continue</string>
    <string name="no_shuffle">Don\'t shuffle</string>
    <string name="shuffle_questions">Shuffle questions</string>
    <string name="shuffle_all">Shuffle questions and answers</string>
    <string name="select_quiz_shuffle">Select shuffling mode</string>
    <string name="quiz_shuffling_mode">Quiz question shuffling</string>
    <string name="challenge_show_code">Show code</string>
    <string name="challenge_hide_code">Hide code</string>
    <string name="quiz_text_4">What class can store the text and its visual style?</string>
    <string name="quiz_text_4_1" translatable="false">*StyledText*</string>
    <string name="quiz_text_4_2" translatable="false">*ColoredSpan*</string>
    <string name="quiz_text_4_3" translatable="false">*AnnotatedString*</string>
    <string name="introduction_1_heading">Jetpack Compose</string>
    <string name="introduction_1_1">Jetpack Compose is recommended toolkit for building UI for Android apps.\nIt simplifies and accelerates UI development, allowing you to create your app with less code, useful tools and intuitive Kotlin APIs.</string>
    <string name="introduction_2_heading">Declarative UI with composables</string>
    <string name="introduction_2_1">In Jetpack Compose, UI elements are created as functions, called composables.\nThese functions describe the UI\'s structure and appearance in a declarative manner.</string>
    <string name="introduction_2_2">Changes in state of the composables automatically triggers updates to the UI, removing the need for manual refreshes.</string>
    <string name="introduction_3_heading">Key benefits of Jetpack Compose</string>
    <string name="introduction_3_1">"Jetpack Compose offers several key benefits, compared to traditional XML-based approach: "</string>
    <string name="introduction_3_2">Better code readability</string>
    <string name="introduction_3_3">Easier maintainability</string>
    <string name="introduction_3_4">Easily adaptable in existing projects</string>
    <string name="introduction_3_5">Features like live preview,  hot reload and full Android Studio support makes developing with Jetpack Compose easier and faster.</string>
    <string name="lesson_setting_up_environment_title">Setting up environment</string>
    <string name="setting_up_1_1">For the best experience developing with Compose, download and install Android Studio.\nIt includes many smart editor features, such as new project templates and the ability to immediately preview your UI and animations.</string>
    <string name="setting_up_1_2">Creating new project</string>
    <string name="setting_up_1_3">To create a new project that has Jetpack Compose setup correctly, proceed as follows:</string>
    <string name="setting_up_1_4">Click *Start a new Android Studio project*.</string>
    <string name="setting_up_1_5">In the *Select a Project Template* window, select *Empty Activity* and click *Next*.</string>
    <string name="setting_up_1_6">In the *Configure your project* window set the *Name*, *Package name* and *Save location* as you normally would.\nIn the *Minimum API level* dropdown menu, select API level 21 or higher.</string>
    <string name="setting_up_1_7">Click *Finish*.</string>
    <string name="setting_up_1_heading" translatable="false">Android Studio</string>
    <string name="setting_up_2_heading">Setting up an existing app</string>
    <string name="setting_up_2_1">Configure the Compose compiler using the *Compose Compiler Gradle* plugin and add the following definition to your app\'s |build.gradle| file:</string>
    <string name="setting_up_2_2">Setting the |compose| flag to |true| inside the build features block enables Compose functionality in Android Studio.</string>
    <string name="setting_up_2_3">Finally, add the Compose BOM and the Compose libraries you plan to use in the |dependencies| block:</string>
    <string name="setting_up_3_heading">Jetpack Compose sample apps</string>
    <string name="setting_up_3_1">The fastest way to experiment with the Jetpack Compose is by trying the sample apps.\nTo import a sample app project from Android Studio, proceed as follows:</string>
    <string name="setting_up_3_2">In the Android Studio welcome screen select *Import an Android code sample*.</string>
    <string name="setting_up_3_3">In the top search bar type \"compose\".</string>
    <string name="setting_up_3_4">Select one of the Jetpack Compose sample apps from the search results and click *Next*.</string>
    <string name="setting_up_3_6">Change the *Application name* and *Project location* or keep the default values.</string>
    <string name="setting_up_3_5">Click *Finish*.</string>
    <string name="setting_up_3_7">Android Studio downloads the sample app and open the projects.\nYou can then inspect |MainActivity.kt| file to see example usage of Jetpack Compose APIs.</string>
    <string name="setting_up_4_heading">Running your app on virtual devices</string>
    <string name="setting_up_4_1">The Android Emulator lets you test your app on many different virtual devices. The emulator is bundled with Android Studio.\nTo use the emulator follow these steps:</string>
    <string name="setting_up_4_2">Emulator system requirements</string>
    <string name="setting_up_4_3" translatable="false">16 GB RAM</string>
    <string name="setting_up_4_4">64-bit Windows 10 or higher, MacOS 12 or higher, Linux, or ChromeOS operating system</string>
    <string name="setting_up_4_5">16 GB disk space</string>
    <string name="setting_up_4_6">Create an Android Virtual Device (AVD)</string>
    <string name="setting_up_4_7">Each instance of the Android Emulator uses and AVD to specify the Android version and hardware of the simulated device.\nTo create an AVD you can use the *Device Manager*.</string>
    <string name="setting_up_4_8">After creating the AVD you can start the Android Emulator and run your project:</string>
    <string name="setting_up_4_9">In the toolbar, select the AVD you want to run your app on.</string>
    <string name="setting_up_4_10">Click *Run*. The emulator might take a while to launch for the first time.</string>
    <string name="setting_up_5_heading">Running your app on a local device</string>
    <string name="setting_up_5_1">Before you can launch you app on your device you need to enable *USB debugging* in the *Developer options*.\nAfter connecting your device to the computer via USB cable you can click *Run* in Android studio to build and start the application on the device.</string>
    <string name="quiz_introduction_1">Which programming language is primarily used in Jetpack Compose?</string>
    <string name="quiz_introduction_1_2" translatable="false">Kotlin</string>
    <string name="quiz_introduction_1_3" translatable="false">Java</string>
    <string name="quiz_introduction_1_1" translatable="false">C++</string>
    <string name="quiz_introduction_2">What is the name of a UI element in Jetpack Compose?</string>
    <string name="quiz_introduction_2_1">Composable</string>
    <string name="quiz_introduction_2_2" translatable="false">View</string>
    <string name="quiz_introduction_2_3" translatable="false">Widget</string>
    <string name="quiz_introduction_3">How is a composable defined in Jetpack Compose?</string>
    <string name="quiz_introduction_3_1">As a class</string>
    <string name="quiz_introduction_3_2">As a function</string>
    <string name="quiz_introduction_3_3">As a constant</string>
    <string name="quiz_setting_up_1">Which IDE is recommended for Jetpack Compose?</string>
    <string name="quiz_setting_up_2">Does Android Studio allow for testing applications on virtual devices?</string>
    <string name="quiz_setting_up_1_1" translatable="false">InteliJ IDEA</string>
    <string name="quiz_setting_up_1_2" translatable="false">Visual Studio</string>
    <string name="quiz_setting_up_1_3" translatable="false">Android Studio</string>
    <string name="quiz_setting_up_2_1">Yes, using the Phone Virtualization System</string>
    <string name="quiz_setting_up_2_2">Yes, using the Android Emulator</string>
    <string name="quiz_setting_up_2_3">No</string>
    <string name="creating_first_2_heading">Composable functions</string>
    <string name="creating_first_2_1">Jetpack Compose is built around composable functions.\nThese functions let you define your app\'s UI programmatically by describing how it should look and providing data, rather than focusing on the process of the UI\'s construction.\nTo create a composable function, just add the |@Composable| annotation to the function name.</string>
    <string name="creating_first_1_heading">Hello, World!</string>
    <string name="lesson_creating_first_title">Creating first Composable</string>
    <string name="creating_first_1_1">To display a simple text on the screen, you can use the |Text| composable inside the |setContent| block.\nThe block acts as an entry point for all UI created in Jetpack Compose.</string>
    <string name="creating_first_1_2">Android Studio should import the required function automatically.\nIf that is not the case you can try to add the import line manually.</string>
    <string name="creating_first_2_2">Composable functions can only be called from other composables or an entry point (like the |setContent| block).</string>
    <string name="creating_first_3_1">You can preview your composables within Android Studio by adding the |@Preview| annotation.\nIn order to preview a composable function it must take no explicit parameters.\nA common practice is to create a second function that calls the previous one with the appropriate arguments.</string>
    <string name="creating_first_3_heading">Displaying preview</string>
    <string name="creating_first_3_2">After creating the preview you should rebuild the project.\nThe app itself doesn\'t change, since the preview function isn\'t called anywhere, but Android Studio adds a preview window.\nYou can expand this window by clicking on the split (design/code) view button.</string>
    <string name="creating_first_3_label_1">Preview window buttons</string>
    <string name="creating_first_3_label_2">Visible preview window in split screen mode</string>
    <string name="setting_up_4_label_1">Device selection popup</string>
    <string name="creating_first_4_heading">Using created composables</string>
    <string name="creating_first_4_1">To use the composable in your app you have to include it in the UI hierarchy by calling it in the entry point.</string>
    <string name="creating_first_4_2">Some composable accept other composable functions as parameter.\nThis can be useful for creating more advanced layouts without making the code overly complex.</string>
    <string name="quiz_creating_first_1">Where can you invoke composable functions?</string>
    <string name="quiz_creating_first_2">What annotation can you use to display created composable inside Android Studio?</string>
    <string name="quiz_creating_first_3">How can you preview composable that requires some parameters?</string>
    <string name="quiz_creating_first_1_1">In all the places you can invoke regular functions</string>
    <string name="quiz_creating_first_1_2">Only in the file with the *MainActivity* class</string>
    <string name="quiz_creating_first_1_3">From other composable functions or entry points</string>
    <string name="quiz_creating_first_2_2" translatable="false">*@DebugView*</string>
    <string name="quiz_creating_first_2_3" translatable="false">*@Composable(preview = true)*</string>
    <string name="quiz_creating_first_3_1">By using default arguments</string>
    <string name="quiz_creating_first_3_2">By creating wrapper preview function that supplies the parameters</string>
    <string name="quiz_creating_first_3_3">Preview can only be used on parameterless functions</string>
    <string name="quiz_button_1">Is it possible to display custom content inside a button?</string>
    <string name="quiz_button_1_1">Yes, you can display any composable inside button</string>
    <string name="quiz_button_1_2">Yes, but only composables annotated with *@Interactable* are allowed</string>
    <string name="quiz_button_1_3">No, you can put only text inside buttons</string>
    <string name="quiz_button_2">What composable you can use to create button with only text visible?</string>
    <string name="quiz_button_2_1" translatable="false">*BlankButton*</string>
    <string name="quiz_button_2_2" translatable="false">*TextButton*</string>
    <string name="quiz_button_2_3" translatable="false">*MinimalButton*</string>
    <string name="quiz_text_field_1">How can you set the number of visible lines in a text field?</string>
    <string name="quiz_text_field_1_1">With the *minLines* and *maxLines* parameters</string>
    <string name="quiz_text_field_1_2">With the *visibleLines* parameter</string>
    <string name="quiz_text_field_1_3">Only through manipulating the displayed string value</string>
    <string name="quiz_text_field_2">Is it possible to modify the appearance of the inputted text?</string>
    <string name="quiz_text_field_2_1">Yes, using the *textMapper* parameter</string>
    <string name="quiz_text_field_2_2">Yes, using the *visualTransformation* parameter</string>
    <string name="quiz_text_field_2_3">Yes, using *AnnotatedString* class</string>
    <string name="quiz_text_field_2_4">Only through custom implementation</string>
    <string name="quiz_text_field_3">Which parameter can be used to display the numeric keypad?</string>
    <string name="quiz_text_field_3_1" translatable="false">*keyboardOptions*</string>
    <string name="quiz_text_field_3_2" translatable="false">*keyboardType*</string>
    <string name="quiz_text_field_3_3" translatable="false">*keyboardMode*</string>
    <string name="quiz_image_1">How can you create a *Painter* object, which is a required parameter of the *Image* composable?</string>
    <string name="quiz_image_1_1">Using the *ImagePainterFactory* class</string>
    <string name="quiz_image_1_2">Using the *painterResource* function</string>
    <string name="quiz_image_1_3">*Painter* objects are created automatically for each image</string>
    <string name="quiz_image_2">What actions are required to draw a vector graphics using the Image composable?</string>
    <string name="quiz_image_2_1">Casting the *VectorDrawable* to *Bitmap*</string>
    <string name="quiz_image_2_2">Specifying the type of the image with the format parameter</string>
    <string name="quiz_image_2_3">The same as when drawing a raster image</string>
    <string name="quiz_modifier_1">On which composables can you apply modifier?</string>
    <string name="quiz_modifier_1_1">To every one</string>
    <string name="quiz_modifier_1_2">Only on those annotated with *@Modifiable*</string>
    <string name="quiz_modifier_1_3">On those that accept Modifier as one of the parameters</string>
    <string name="quiz_modifier_2">Does order of applied modifiers affect the result?</string>
    <string name="quiz_modifier_2_1">Yes</string>
    <string name="quiz_modifier_2_2">Yes, if the modifier is not annotated as *@Stable*</string>
    <string name="quiz_modifier_2_3">No</string>
    <string name="quiz_modifier_3">is it required to create new modifier for each composable?</string>
    <string name="quiz_modifier_3_1">No, if the composables are in the same file</string>
    <string name="quiz_modifier_3_2">No</string>
    <string name="quiz_modifier_3_3">Yes, reusing modifiers can create unintended side effects</string>
    <string name="quiz_card_1">How can you make card clickable?</string>
    <string name="quiz_card_1_1">By creating a button inside it</string>
    <string name="quiz_card_1_2">By passing callback to the *onClick* parameter</string>
    <string name="quiz_card_1_3">By using the *ClickableCard* composable</string>
    <string name="quiz_card_2">Is it possible to change shape of the card?</string>
    <string name="quiz_card_2_1">No, cards have constant default shape</string>
    <string name="quiz_card_2_2">Yes, using the *cornerRadius* parameter</string>
    <string name="quiz_card_2_3">Yes, by providing custom *Shape* object for the *shape* parameter</string>
    <string name="lesson_box_title">Box</string>
    <string name="lesson_column_row_title">Column and row</string>
    <string name="lesson_grid_title">Grid</string>
    <string name="lesson_scaffold_title">Scaffold</string>
    <string name="box_1_heading">Aligning items in a box</string>
    <string name="box_2_heading">Default alignment</string>
    <string name="box_3_heading">Matching size</string>
    <string name="column_row_1_heading">Using layout</string>
    <string name="column_row_2_heading">Adding content</string>
    <string name="column_row_3_heading">Aligning content</string>
    <string name="column_row_4_heading">Types of arrangements - column</string>
    <string name="column_row_5_heading">Types of arrangements - row</string>
    <string name="column_row_6_heading">Weight</string>
    <string name="column_row_7_heading">Scrolling content</string>
    <string name="column_row_8_heading">Lazy containers</string>
    <string name="column_row_9_heading">Controlling scroll position</string>
    <string name="column_row_10_heading">Animating content change</string>
    <string name="grid_1_heading">Creating grids</string>
    <string name="grid_2_heading">Cell size</string>
    <string name="grid_3_heading">Horizontal grid</string>
    <string name="grid_4_heading">Content layout</string>
    <string name="grid_5_heading">Animating content change</string>
    <string name="grid_6_heading">Controlling scroll position</string>
    <string name="grid_7_heading">Staggered grids</string>
    <string name="scaffold_1_heading">Consistent UI layout</string>
    <string name="scaffold_2_heading">Types of scaffold components</string>
    <string name="scaffold_4_heading">FAB position</string>
    <string name="column_row_1_1">Composable functions can create multiple UI elements. Without any guidance, Compose might arrange them in a not desirable way.\nFor example, the following function creates two texts without specifying any layout:</string>
    <string name="column_row_1_2">After specifying the layout, the texts are composed in a more predictable manner:</string>
    <string name="column_row_1_3">In many cases, the |Column| and |Row| composition functions are sufficient to create different application interface layouts.</string>
    <string name="column_row_2_1">|Column| and |Row| accept multiple composables as their content.\nYou can also nest multiple rows and columns to create more advanced design.</string>
    <string name="column_row_2_2">When adding multiple composables to the container, the |repeat| function might be useful:</string>
    <string name="column_row_3_1">You can specify how the content should be arranged inside the container by specifying the |verticalAlignement| and |horizontalArrangement| for rows and |verticalArrangement| and |horizontalAlignment| for columns.</string>
    <string name="column_row_3_2">|Arrangement| class also provides functionality for spacing the content with the |spacedBy| method:</string>
    <string name="column_row_expand">Expand</string>
    <string name="column_row_collapse">Collapse</string>
    <string name="column_row_6_1">Elements inside columns and rows can have assigned weights to split the available space accordingly.\nThe higher the element\'s weight, the more space will it occupy.</string>
    <string name="column_row_7_1">When the content doesn\'t fit inside the container, you can enable scrolling by using the |horizontalScroll| or |verticalScroll| modifiers.</string>
    <string name="column_row_8_1">When you want to display a large or unknown amount of elements, you should consider using the lazy versions of the containers: |LazyColumn| and |LazyRow|.\nThey can improve the performance of the app significantly by rendering only these elements that are currently visible.</string>
    <string name="column_row_8_2">Lazy containers don\'t accept other composables as their content directly — you should use the |item| or |items| functions.</string>
    <string name="column_row_9_1">Lazy containers allow you to control the scroll position programmatically by using the |LazyListState|.\nThis can be useful if you want to disable the scroll gestures, or to scroll to specific item.\nMethods controlling the scroll are |suspend|ing, so you must call them inside a |coroutineScope|.</string>
    <string name="column_row_10_1">You can animate the changes of the displayed elements by using the |animateItem| modifier.\nIf the displayed composables are more complex, consider providing unique key for each of them in the |items| function. This can help Compose keep track of them and apply correct animations.</string>
    <string name="box_1_1">|Box| can be used to put elements on top of another, while allowing for specifying their alignment.</string>
    <string name="box_1_2">Elements inside a box can use the |align| modifier to configure their alignment.</string>
    <string name="box_2_1">Instead of setting the alignment on each item separately, you can use the |contentAlignment| parameter to apply the alignment to whole content.</string>
    <string name="box_3_1">Another use for |Box| is to match the content size to the container\'s. You can do this using the |matchParentSize| modifier.</string>
    <string name="grid_1_1">Grids are another type of lazy containers. The |LazyVerticalGrid| and |LazyHorizontalGrid| composables provide support for displaying items in a grid.\nLike the |LazyColumn| and |LazyRow| they also provide |item| and |items| functions for adding content.</string>
    <string name="grid_1_2">When creating grids you must specify the count columns (or rows).</string>
    <string name="grid_2_1">Instead of setting the count of the columns (or rows) you can set their size.\nYou can make them have fixed size or be adaptive. Adaptive cells will take at least the specified space and divide the remaining equally.</string>
    <string name="grid_3_1">Creating horizontal grid is very similar to vertical: simply replace |LazyVerticalGrid| with |LazyHorizontalGrid| and use the |rows| parameter instead of |columns|.</string>
    <string name="grid_4_1">Gird allows you to change the arrangement of the content similarly to lists with the difference being they use both |VerticalArrangement| and |HorizontalArrangement| and no alignment.</string>
    <string name="grid_5_1">Like in the lists, you can animate changes in content with the |animateItem| modifier and providing key for each element.</string>
    <string name="grid_6_1">Using |LazyGridState| you can programmatically control the scroll position. For staggered grid you should use |StaggeredGridState| instead.</string>
    <string name="grid_7_1">Staggered grids allow the displayed items to have different size across the main axis.</string>
    <string name="quiz_column_row_1">Can you use nested columns and rows?</string>
    <string name="quiz_column_row_1_1">Yes</string>
    <string name="quiz_column_row_1_2">Yes, but can you use at most 2</string>
    <string name="quiz_column_row_1_3">It is not allowed</string>
    <string name="quiz_column_row_2">How can you make a column scrollable?</string>
    <string name="quiz_column_row_2_1">By using the *ScrollableColumn* composable</string>
    <string name="quiz_column_row_2_2">By applying the *verticalScroll* modifier</string>
    <string name="quiz_column_row_2_3">Columns and rows are scrollable by default</string>
    <string name="quiz_column_row_3">Which composables is best suited for displaying large amount of items?</string>
    <string name="quiz_column_row_3_1" translatable="false">*LazyList*</string>
    <string name="quiz_column_row_3_2" translatable="false">*RecyclerColumn*</string>
    <string name="quiz_column_row_3_3" translatable="false">*LazyColumn*</string>
    <string name="quiz_box_1">How can you position the content of the *Box*?</string>
    <string name="quiz_box_1_1">By using the container\'s *contentAlignment* parameter</string>
    <string name="quiz_box_1_2">By using the content\'s *alignment* parameter</string>
    <string name="quiz_box_1_3">By applying the *align* modifier on the content</string>
    <string name="quiz_box_1_4">By placing the content inside *Align* block</string>
    <string name="quiz_box_2">Does *Box* allow for multiple content items?</string>
    <string name="quiz_box_2_1">*Box* supports only single inner composable</string>
    <string name="quiz_box_2_2">*Box* can contain any amount of composables</string>
    <string name="quiz_box_2_3">*Box* can contain up to 3 composables</string>
    <string name="quiz_grid_1">How can you set content of the lazy grids?</string>
    <string name="quiz_grid_1_1">By placing them directly inside the *content* lambda</string>
    <string name="quiz_grid_1_2">By using the *item* or *items* functions</string>
    <string name="quiz_grid_1_3">By using the *setContent* function</string>
    <string name="quiz_grid_2">How can you make a *VerticalLazyGrid* scrollable?</string>
    <string name="quiz_grid_2_1">By applying the *LazyScrollable* modifier</string>
    <string name="quiz_grid_2_2">By setting the *scrollable* parameter to *true*</string>
    <string name="quiz_grid_2_3">Lazy grids are scrollable by default</string>
    <string name="quiz_grid_3">How can you add spacing between items inside *LazyVerticalGrid*?</string>
    <string name="quiz_grid_3_1">With the *itemSpacing* parameter</string>
    <string name="quiz_grid_3_2">By using *Arrangement.spacedBy* for *verticalArrangement* and *horizontalArrangement* parameters</string>
    <string name="quiz_grid_3_3">By applying *contentPadding* modifier</string>
    <string name="scaffold_3_fab">Change FAB position</string>
    <string name="scaffold_2_top_bar">Top bar</string>
    <string name="scaffold_2_bottom_bar">Bottom bar</string>
    <string name="scaffold_2_fab" translatable="false">FAB</string>
    <string name="scaffold_5_heading" translatable="false">Snackbar</string>
    <string name="scaffold_5_snackbar">Show snackbar</string>
    <string name="scaffold_1_content">Scaffold content</string>
    <string name="scaffold_3_heading">Content color</string>
    <string name="scaffold_1_1">In Jetpack Compose, a scaffold is a structure that facilitates creating complex UI in a standardized way.\nIt has a modular structure, allowing you to pick the parts that works best for your app.</string>
    <string name="scaffold_2_1">The main components of the *Scaffold* are the Top App Bar, the Bottom App Bar, and the FAB (Floating Action Button).\nEach of these components comes in several different versions.</string>
    <string name="scaffold_3_1">You can customize the default colors of the content with the |containerColor| and |contentColor| parameters.</string>
    <string name="scaffold_4_1">You can change the FAB position with the |floatingActionButtonPosition| parameter. The available positions are |Start|, |Center|, |End| and |EndOverlay|.</string>
    <string name="scaffold_5_1">Another component of |Scaffold| is the snackbar. It it used to display short messages to the user. Unlike the toasts, snackbar messages can be interacted with.</string>
    <string name="scaffold_5_2">To use the snackbar, you can use the |snackbarHost| parameter like so:</string>
    <string name="scaffold_5_3">In order to display a message you can use the |showSnackbar| method.\nSnackbar messages can have different duration and optional action label.\nYou can check if the action label was clicked by the user using the return value of the method. Note that displaying snackbar messages is a suspending operation.</string>
    <string name="scaffold_3_2">Note that, when adding content to the scaffold, you should use the provided padding values:</string>
    <string name="scaffold_5_4">You can hide the current message by using this approach:</string>
    <string name="quiz_scaffold_1">What are the main components of a scaffold?</string>
    <string name="quiz_scaffold_1_5" translatable="false">Main App Bar</string>
    <string name="quiz_scaffold_1_2" translatable="false">Content Padding</string>
    <string name="quiz_scaffold_1_3" translatable="false">Bottom App Bar</string>
    <string name="quiz_scaffold_1_4" translatable="false">FAB</string>
    <string name="quiz_scaffold_1_1" translatable="false">Top App Bar</string>
    <string name="quiz_scaffold_2">What is the main purpose of the scaffold?</string>
    <string name="quiz_scaffold_2_1">To be used as a more advanced alternative to *Box*</string>
    <string name="quiz_scaffold_2_2">Improving the app\'s UI performance</string>
    <string name="quiz_scaffold_2_3">Being the main container for other composables</string>
    <string name="quiz_scaffold_3">How can you check whether user clicked the snackbar action?</string>
    <string name="quiz_scaffold_3_1">By checking the *wasClicked* field on the snackbar host</string>
    <string name="quiz_scaffold_3_2">By checking the return value of the *showSnackbar* method</string>
    <string name="quiz_scaffold_3_3">By checking the state of the *GlobalSnackbarController*</string>
    <string name="quiz_creating_first_2_1" translatable="false">*@Preview*</string>
    <string name="lesson_color_scheme_title">Color scheme</string>
    <string name="color_scheme_1_heading">Creating application color scheme</string>
    <string name="color_scheme_2_heading">Using the color scheme</string>
    <string name="color_scheme_3_heading">Applying colors with modifiers</string>
    <string name="lesson_material_theme_title" translatable="false">Material Theme</string>
    <string name="lesson_app_theme">App themes and dynamic colors</string>
    <string name="app_theme_1_heading">Using dark color theme</string>
    <string name="app_theme_2_heading">Dynamic color scheme</string>
    <string name="app_theme_3_heading">Displaying edge to edge</string>
    <string name="grid_2_2">Grid with |FixedSize| cells:</string>
    <string name="grid_2_3">Grid with |Adaptive| cells:</string>
    <string name="app_theme_2_current">Current theme: %1$s</string>
    <string name="use_dynamic_colors">Use dynamic color scheme</string>
    <string name="dynamic_colors">Dynamic color scheme</string>
    <string name="app_theme_3_current">Dynamic colors: %1$s</string>
    <string name="material_theme_1_heading">Creating Material Theme color scheme</string>
    <string name="material_theme_2_heading">Applying theme to the app</string>
    <string name="material_theme_3_heading">Using the color scheme</string>
    <string name="material_theme_4_heading">Creating typography</string>
    <string name="material_theme_5_heading">Using the typography</string>
    <string name="material_theme_6_heading">Creating shapes</string>
    <string name="material_theme_7_heading">Using the shapes</string>
    <string name="material_theme_8_heading">Custom theme scope</string>
    <string name="color_scheme_1_1">You can create color palette for you application using XML resources.\nCreating a palette allows for easier reuse of colors and helps make your application design become more consistent.</string>
    <string name="color_scheme_1_2">Example |colors.xml| file:</string>
    <string name="color_scheme_1_3">To access the colors from the palette you can use the |colorResource| function:</string>
    <string name="color_scheme_2_1">Many composables have defined default values (eg. |CardDefaults|) that help when applying the color palette.</string>
    <string name="color_scheme_3_1">If the composable doesn\'t accept colors directly you can use the |background| modifier to set the background color.</string>
    <string name="material_theme_1_1">Material theme is a more standardized way of creating an application theme. When creating color scheme, the individual colors are named based of their function rather than their value.</string>
    <string name="material_theme_1_2">After creating the color scheme you can use it in the |MaterialTheme| composable to apply it to the content.</string>
    <string name="material_theme_2_1">You can apply the theme to the whole app by wrapping it\'s layout inside the created |AppTheme| composable.\nDoing this will make sure that the look of each composable is consistent with the design.</string>
    <string name="material_theme_2_2">Applying the theme to the entire app inside the |MainActivity.kt| file:</string>
    <string name="material_theme_3_1">In order to access specific colors you can use the |MaterialTheme.colorScheme| object.\nThe descriptive names of the colors help you decide which color is best suited for specific role in the UI hierarchy.</string>
    <string name="material_theme_3_2">An example of a color combination is |primaryContainer| with |onPrimaryContainer|. These colors provide a natural look and appropriate contrast of the UI elements.</string>
    <string name="material_theme_1_3">Creating custom color schemes can be streamlined by using the Material 3 online color generator.</string>
    <string name="material_theme_4_1">|MaterialTheme| can also be used to specify the typography for your app.</string>
    <string name="material_theme_5_1">To use the created text styles you can use the |MaterialTheme.typography| object.</string>
    <string name="material_theme_6_1">The shapes of the composables can also be customized using |MaterialTheme|</string>
    <string name="material_theme_7_1">Most composables use the specified shapes automatically. When you want to set it explicitly you can use the |MaterialTheme.shapes| object.</string>
    <string name="material_theme_8_1">You can opt-out of the main design of the application by creating separate |MaterialTheme| scope with different values:</string>
    <string name="app_theme_1_1">You can add the ability to change the app theme by creating separate color schemes for light and dark mode and deciding which to use based on certain condition.</string>
    <string name="app_theme_1_2">You can determine whether the device uses dark system theme by using the |isSystemInDarkTheme| function.</string>
    <string name="app_theme_2_1">Devices with Android 12 and above can use the dynamic colors feature.\nThis feature uses special algorithm that creates custom color scheme based on the user\'s wallpaper.\nThis allows the app to become more personalized and better match the system theme.</string>
    <string name="app_theme_2_2">To create the dynamic color scheme you can use the |dynamicDarkColorScheme| or |dynamicLightColorScheme| functions.</string>
    <string name="app_theme_no_e2e">Top app bar with *edge to edge* disabled:</string>
    <string name="app_theme_e2e">Top app bar with *edge to edge* enabled:</string>
    <string name="app_theme_3_1">Apps targeting SDK 35 or later have edge-to-edge enabled automatically when running on Android 15. To enable edge-to-edge on previous Android versions, do the following:</string>
    <string name="app_theme_3_2">1. Add |androidx.activity| library to the dependencies in the |build.gradle| file:</string>
    <string name="app_theme_3_3">2. Import and the |enableEdgeToEdge| function and call it inside the |onCreate| method of your activity.</string>
    <string name="quiz_app_theme_1">Which function can be used to determine the system theme?</string>
    <string name="quiz_app_theme_1_1" translatable="false">*getSystemTheme*</string>
    <string name="quiz_app_theme_1_2" translatable="false">*isSystemInDarkTheme*</string>
    <string name="quiz_app_theme_1_3" translatable="false">*isSystemInLightTheme*</string>
    <string name="quiz_app_theme_2">From which Android version is the dynamic colors feature available?</string>
    <string name="quiz_app_theme_2_1" translatable="false">Android 12</string>
    <string name="quiz_app_theme_2_2" translatable="false">Android KitKat</string>
    <string name="quiz_app_theme_2_3" translatable="false">Android 14</string>
    <string name="quiz_app_theme_3">How can you enable edge-to-edge display?</string>
    <string name="quiz_app_theme_3_1">Using the *setFullScreen(true)* function</string>
    <string name="quiz_app_theme_3_2">"By setting the *edgeToEdge* to *true* in the app's manifest "</string>
    <string name="quiz_app_theme_3_3">Using the *enableEdgeToEdge* function</string>
    <string name="quiz_color_scheme_1">How can you access the colors defined in the resource files?</string>
    <string name="quiz_color_scheme_1_1">Using the *R.color* directly</string>
    <string name="quiz_color_scheme_1_2">Using the *colorResource* function</string>
    <string name="quiz_color_scheme_1_3">By copying the HEX value of the color in resource file</string>
    <string name="quiz_color_scheme_2">How can you change the color of a composable that doesn\'t accept any color parameter?</string>
    <string name="quiz_color_scheme_2_1">By placing it inside *Color* block</string>
    <string name="quiz_color_scheme_2_2">By applying the *background* modifier</string>
    <string name="quiz_color_scheme_2_3">It is not possible</string>
    <string name="quiz_material_theme_1">Colors in Material Theme are named after:</string>
    <string name="quiz_material_theme_1_1">Their RGB values</string>
    <string name="quiz_material_theme_1_2">Their function</string>
    <string name="quiz_material_theme_1_3">Standard codenames</string>
    <string name="quiz_material_theme_2">What does the size of Material Theme shape indicate?</string>
    <string name="quiz_material_theme_2_1">The size of the composable</string>
    <string name="quiz_material_theme_2_2">Inner padding of the composable</string>
    <string name="quiz_material_theme_2_3">Corner radius of the composable</string>
    <string name="quiz_material_theme_3">Can composables inside *MaterialTheme* be additionally customized?</string>
    <string name="quiz_material_theme_3_1">No</string>
    <string name="quiz_material_theme_3_2">Yes, by using the *@Override* annotation on the style</string>
    <string name="quiz_material_theme_3_3">Yes, by creating new *MaterialTheme* block</string>
    <string name="lesson_remember_title">Remembering state</string>
    <string name="lesson_view_model_title">Using viewModel</string>
    <string name="lesson_persistent_title">Persistent state</string>
    <string name="lesson_lifecycle_title">Lifecycle of composables</string>
    <string name="remember_1_heading">State objects and remember function</string>
    <string name="remember_2_heading">Updating UI</string>
    <string name="remember_3_heading">State hoisting</string>
    <string name="remember_4_heading">Restoring state</string>
    <string name="remember_5_heading">Invalidating state</string>
    <string name="lifecycle_1_heading">Composition and recomposition</string>
    <string name="lifecycle_1_1">When Jetpack Compose runs your composables fo the first time, during #initial composition#, it will keep track of the called composables that describe the UI in a Composition.\nWhen the state of the app changes, Jetpack Compose schedules a #recomposition#. Recomposition re-executes the composables that may have changed in response to the state change, and then updates the Composition to reflect and changes.</string>
    <string name="lifecycle_1_2">A *Composition* can only be produced by an initial composition and then updated by recomposition.\nThe only way to modify a *Composition* is through recomposition.</string>
    <string name="lifecycle_1_label">Lifecycle diagram of a composable</string>
    <string name="lifecycle_1_3">Recomposition is usually triggered by a change to a |State&lt;T&gt;| object. Compose tracks such objects and runs all composables that read the changed state object.</string>
    <string name="lifecycle_2_heading">Instances of composable</string>
    <string name="lifecycle_2_1">The instance of a composable in Composition is identified by its *call site*. The Compose compiler considers each call site as unique.\nCalling composables from multiple call sites will create multiple instances of the composables in Composition.</string>
    <string name="lifecycle_2_2">If during a recomposition a composable calls different composables than it did during the previous composition, Compose will identify which composables were or were not called.\nIn case a composable was called in both compositions, Compose will avoiding recomposing it if its inputs haven\'t changed.</string>
    <string name="lifecycle_3_heading">Multiple composables in one call site</string>
    <string name="lifecycle_3_1">When calling a composable multiple times from the same call site, Compose doesn\'t have any information to uniquely identify each call to that composable, so the order of execution is used in addition to the call site in order to keep the instances distinct.</string>
    <string name="lifecycle_3_2">In the example above, Compose uses the execution order in addition to the call site to keep the instances distinct in the Composition.\nIf a new |user| is added to the #bottom# of the list, Compose can reuse the instances present in the Composition.</string>
    <string name="lifecycle_3_3">However, if the |users| changes either by adding to the #top# or #middle# of the list, removing or reordering items, it\'ll cause a recomposition in all |UserCard| calls whose input parameter has changed position in the list.\nAdditionally, if the composable recomposes, any ongoing operations (such as downloading an image) is cancelled and restarted.</string>
    <string name="lifecycle_4_heading">Skipping recompositions</string>
    <string name="lifecycle_4_1">You can help Compose identifying composables by wrapping them in the |key| composable. The value for a |key| doesn\'t need to be #globally# unique, it only needs to be unique for the current call site.</string>
    <string name="remember_1_1">In Jetpack Compose state of the UI is represented using the observable |State| types. When creating state object inside a composable you should wrap it in |remember| function.\nThe |remember| function stores the result of the computation during initial composition and reuses it later during recompositions.</string>
    <string name="remember_1_2">There are three way to create a |MutableState| object in a composable:</string>
    <string name="remember_1_3">These declarations are equivalent. You should pick the one that is the easiest to read for you.\nThe |by| delegate syntax requires the following imports:</string>
    <string name="remember_2_1">The |State| objects are responsible for triggering the recompositions and updating the UI.\nWhile the |remember| function accepts any parameters, only modifying state objects will result in change to the UI.</string>
    <string name="remember_2_2">In this example, both buttons have an identical lambda |onClick|. You can see that the *CountInt* button does not update when clicked.</string>
    <string name="remember_3_1">A composable that uses |remember| to store an object creates internal state, resulting in the composable being #stateful#. Stateful composables can be easier to use but they tend to be less reusable and flexible.</string>
    <string name="remember_3_2">You can make a stateful composition function stateless using *state hoisting*. This involves replacing the state variable with two parameters: one giving the current value and the other being a callback to request a change to the value.</string>
    <string name="remember_3_3">State that is hoisted this way has some important properties:</string>
    <string name="remember_3_4">*Single source of truth*: Moving the state instead of duplicating it helps avoid many bugs.</string>
    <string name="remember_3_5">*Encapsulated*: Only stateful composables can modify their internal state.</string>
    <string name="remember_3_6">*Shareable*: Hoisted state can be shared with multiple composables.</string>
    <string name="remember_4_1">|rememberSaveable| function allows you to remember state not only across recompositions but also across activity or process recreations.\nFor example, this happens, when the screen is rotated or when changing system theme.</string>
    <string name="remember_4_2">The first text field will lose its content after rotating the screen while the second one will retain it.</string>
    <string name="remember_5_1">You can re-trigger remember calculations by providing key parameters to the |remember| and |rememberSaveable|. When any of the keys change, the functions will forget their value and calculate it again.</string>
    <string name="quiz_lifecycle_1">How can a *Composition* be modified?</string>
    <string name="quiz_lifecycle_1_1">By using any composable function</string>
    <string name="quiz_lifecycle_1_2">By triggering a recomposition</string>
    <string name="quiz_lifecycle_1_3">New *Composition* is created that replaces the old one</string>
    <string name="quiz_lifecycle_2">How does Compose identify composable instances?</string>
    <string name="quiz_lifecycle_2_1">Only by the call site</string>
    <string name="quiz_lifecycle_2_2">By their input parameters</string>
    <string name="quiz_lifecycle_2_3">By the call site and execution order</string>
    <string name="quiz_lifecycle_3">During recomposition, which composables are re-executed?</string>
    <string name="quiz_lifecycle_3_1">Every one</string>
    <string name="quiz_lifecycle_3_2">Those whose input parameters may have changed</string>
    <string name="quiz_lifecycle_3_3">Only those that return *Unit*</string>
    <string name="quiz_remember_1">What is the recommended way for creating state object inside a composable function?</string>
    <string name="quiz_remember_1_2">Creating a *MutableStateOf* inside *remember*</string>
    <string name="quiz_remember_1_1">Using *remember* to save any value</string>
    <string name="quiz_remember_1_3">Using *createState* function</string>
    <string name="quiz_remember_2">How can you change stateful composable to stateless?</string>
    <string name="quiz_remember_2_1">By not using the *remember* function</string>
    <string name="quiz_remember_2_2">By storing all the state in separate class</string>
    <string name="quiz_remember_2_3">By using the *state hoisting* pattern</string>
    <string name="quiz_remember_3">How can you persist state across *Compositions*?</string>
    <string name="quiz_remember_3_1">By providing *key* parameter to the *remember* function</string>
    <string name="quiz_remember_3_2">By using *rememberSaveable*</string>
    <string name="quiz_remember_3_3">By using data classes for storing the state</string>
    <string name="remember_4_3">Because |rememberSaveable| stores the data in the |Bundle| saving complex types is not as straightforward as when using |remember|.\nThe simplest solution is to annotate your type with |@Parcelize|. Another options is to use |mapSaver| to define your own rules for converting an object into set of values that can be saved in |Bundle|.</string>
    <string name="lesson_bottom_sheet_title">Bottom sheet</string>
    <string name="bottom_sheet_display">Display bottom sheet</string>
    <string name="bottom_sheet_hide">Hide bottom sheet</string>
    <string name="bottom_sheet_1_content">Click outside or swipe down to close the sheet</string>
    <string name="bottom_sheet_2_content">Swipe up to expand sheet. Swipe down to dismiss.</string>
    <string name="bottom_sheet_1_heading">Displaying the bottom sheet</string>
    <string name="bottom_sheet_2_heading">Partially expanding the sheet</string>
    <string name="bottom_sheet_3_heading">Specifying width and handle</string>
    <string name="bottom_sheet_4_heading">Customizing appearance</string>
    <string name="viewmodel_1_heading">Creating viewModel</string>
    <string name="viewmodel_2_heading">Exposing UI state</string>
    <string name="viewmodel_3_heading">Using viewModel in composables</string>
    <string name="viewmodel_4_heading">Asynchronous operations</string>
    <string name="viewmodel_5_heading">Best practices</string>
    <string name="persistent_1_heading">Saving data in preferences</string>
    <string name="persistent_2_heading">Storing and retrieving data</string>
    <string name="persistent_3_heading">Connecting with viewModel</string>
    <string name="persistent_4_heading">Accessing stored data in composables</string>
    <string name="biometrics_auth_failed">Authentication failed</string>
    <string name="biometrics_not_set">Authentication not set</string>
    <string name="biometrics_auth_success">Authentication success</string>
    <string name="biometrics_feature_unavailable">Feature unavailable</string>
    <string name="biometrics_hardware_unavailable">Hardware unavailable</string>
    <string name="lesson_biometrics_title">Biometrics</string>
    <string name="lesson_notification_title">System notifications</string>
    <string name="lesson_pager_title">Pager</string>
    <string name="lesson_nav_ctr_host_title">Nav controller and host</string>
    <string name="lesson_nav_containers_title">Navigation containers</string>
    <string name="lesson_back_handler_title">Back handler</string>
    <string name="lesson_navigation_suite_title">Navigation suite</string>
    <string name="lesson_animated_visibility_title">Animating content</string>
    <string name="lesson_animate_values_title">Animating values</string>
    <string name="lesson_nav_transitions_title">Navigation transitions</string>
    <string name="navigation_1_heading">Creating navigation controller</string>
    <string name="navigation_2_heading">Navigation graph</string>
    <string name="navigation_3_heading">Navigation between screens</string>
    <string name="navigation_4_heading">Passing data</string>
    <string name="navigation_5_heading">Deep links</string>
    <string name="animation_toggle">Toggle</string>
    <string name="animating_values_1_heading">Animate as state</string>
    <string name="animating_values_2_heading">Animating DP</string>
    <string name="animating_values_3_heading">Custom animation spec</string>
    <string name="animating_values_4_heading">Animating multiple values</string>
    <string name="animating_values_5_heading">Infinite animation</string>
    <string name="animated_visibility_click">Click to toggle visibility</string>
    <string name="animated_visibility_1_heading">Animating visibility</string>
    <string name="animated_visibility_2_heading">Types of Transitions</string>
    <string name="animated_visibility_3_heading">Combining transitions</string>
    <string name="animated_visibility_4_heading">Animating child content</string>
    <string name="animated_visibility_5_heading">Animating content changes</string>
    <string name="pager_scroll_forward">Scroll forward</string>
    <string name="pager_scroll_backward">Scroll backward</string>
    <string name="pager_current_page_snackbar">Current page</string>
    <string name="pager_1_heading">Vertical and horizontal pager</string>
    <string name="pager_2_heading">Lazy layout</string>
    <string name="pager_3_heading">Controlling position</string>
    <string name="pager_4_heading">Listening for page changes</string>
    <string name="pager_5_heading">Page indicator</string>
    <string name="pager_6_heading">Custom page sizes</string>
    <string name="nav_drawer_text">Swipe to the right to open the drawer</string>
    <string name="nav_drawer_text_2">Click to open navigation drawer</string>
    <string name="nav_containers_1_heading">Bottom navigation bar</string>
    <string name="nav_containers_3_heading">Creating the bottom bar</string>
    <string name="nav_containers_4_heading">Customizing navigation items</string>
    <string name="nav_containers_5_heading">Navigation drawer</string>
    <string name="nav_containers_6_heading">Controlling drawer state</string>
    <string name="nav_containers_7_heading">Customizing drawer appearance</string>
    <string name="nav_containers_8_heading">Syncing navigation route</string>
    <string name="back_3_first">First back</string>
    <string name="back_3_second">Second back</string>
    <string name="back_handled">Back pressed</string>
    <string name="back_3_heading">Double back handler</string>
    <string name="back_2_heading">Conditional handling</string>
    <string name="back_1_heading">Invoking actions on back</string>
    <string name="back_text_not_empty">The text is not empty</string>
    <string name="lesson_side_effects_title">Side effects</string>
    <string name="side_effects_5_heading" translatable="false">RememberUpdatedState</string>
    <string name="side_effects_4_heading">Exposing Compose state</string>
    <string name="side_effects_3_heading">Cleaning up resources</string>
    <string name="side_effects_2_heading">Accessing coroutine scope</string>
    <string name="side_effects_1_heading">Performing asynchronous operations</string>
    <string name="navigation_1_1">Navigation allows you to create more advanced apps that feature multiple distinct screens.</string>
    <string name="navigation_1_2">To add support for navigation, add the following dependency in your app\'s |build.grade| file:</string>
    <string name="navigation_1_3">To use more modern and typesafe way of navigating, you should also include the |kotlin-serialization| plugin:</string>
    <string name="navigation_2_1">The |navController| allows you to move between destinations. You can create it using the |rememberNavController| function.</string>
    <string name="navigation_2_2">To define a #route# use a serializable object. A route describes how to access the destination.\nOnce you have defined your routes, use the |NavHost| composable to create your navigation graph.</string>
    <string name="navigation_2_3">Instead of creating the graph inside the |NavHost|, you can use the |navController.createGraph| method to create it separately and pass it to the |NavHost| directly:</string>
    <string name="navigation_3_1">To navigate between destinations you can use the |navController.Navigate&lt;T&gt;| method. This overload takes a single argument, representing the destination.</string>
    <string name="navigation_3_2">To return to previous destination you can use the |navController.navigateUp| or |navController.popBackStack| method.</string>
    <string name="navigation_4_1">If you need to pass some data to the destination, you can define the route with a class that accepts parameters:</string>
    <string name="navigation_4_2">To access the data in the route you can use the |toRoute&lt;T&gt;| method on the |navBackStackEntry|.</string>
    <string name="navigation_5_send_deeplink">Send deep link notification</string>
    <string name="navigation_5_1">Navigation in Jetpack Compose also allows you to define *deep links*. Deep links let you associate a specific URL with a composable.\nDeep links can be used to enable opening the app from a notification or browser.</string>
    <string name="navigation_5_2">When creating the deep link you can use any scheme and host if you don\'t plan to allow the users to open the app from the browser.\nDeep links can also contain data, just like regular routes.</string>
    <string name="navigation_5_3">By default, deep links are not exposed to external apps. To make them externally available you must add the appropriate |&lt;intent-filter&gt;| element to your app\'s |manifest.xml| file.\nWhen specifying the |host| parameter, you can provide multiple values to match the element to multiple hosts.</string>
    <string name="back_1_1">When the user presses the system back button, by default the app navigates to the previous screen or closes if it currently is on the starting destination.\nYou can change this behaviour using the |BackHandler| composable function.</string>
    <string name="back_1_2">When a back handler is present in the Composition it will invoke the lambda instead of navigating back.</string>
    <string name="back_2_1">You can conditionally enable the |BackHandler| using the |enabled| parameter.\nDisabled handler will not invoke the lambda and will not stop navigation.</string>
    <string name="back_3_1">You can handle multiple consecutive back presses by using multiple |BackHandler|.\nAn enum can be useful for tracking the current state of the back presses and enabling the appropriate handlers.</string>
    <string name="back_3_2">To make sure the back state returns to the default state after a while, you can use the |LaunchedEffect| function.\nThis will allow you to delay the reset of the state for a specified amount of time.</string>
    <string name="nav_containers_2_heading">Creating route objects</string>
    <string name="nav_containers_1_1">If your app uses navigation, you can improve the user experience by using special layout that informs the user that they can indeed navigate in the app.</string>
    <string name="nav_containers_1_2">A good example of such layout is the bottom navigation bar. It clearly conveys the information about current route and the other available.</string>
    <string name="nav_containers_2_1">To make the managing of the routes easier, you can use a simple data structure that holds the basic information about the route: its name, icon and the destination route object.</string>
    <string name="nav_containers_3_1">To create the bottom navigation bar you can use |NavigationBar| composable inside the |Scaffold|.\nA good practice is creating list of available routes so you can create all the |NavigationBarItem|s using a simple loop.</string>
    <string name="nav_containers_3_2">To determine which navigation item is currently selected, you can save the index of clicked item with |rememberSaveable|</string>
    <string name="nav_containers_4_1">|NavigationBarItem|s can be customized by changing their colors and label.\nYou can also choose whether to always display the label, or only when the item is currently selected, with the |alwaysShowLabel| parameter.</string>
    <string name="nav_containers_5_1">Another layout commonly used with navigation is navigation drawer.\nYou can create it using the |ModalNavigationDrawer| composable and providing drawer content with the |ModalDrawerSheet|:</string>
    <string name="nav_containers_5_2">By default, the drawer can be opened by swiping to the right on the screen and closed by swiping to the left.</string>
    <string name="nav_containers_6_1">You can control the state of the drawer by creating the state manually using the |rememberDrawerState| function and passing it explicitly to the |ModalNavigationDrawer|.</string>
    <string name="nav_containers_6_2">Using the created state you can programmatically open or close the drawer with the suspending functions |drawerState.open| and |drawerState.close|.\nYou can also disable the default gestures with the |gesturesEnabled| parameter.</string>
    <string name="nav_containers_7_1">The navigation drawer sheet can be customized by providing values for the |drawerContainerColor|, |drawerContentColor| and |drawerShape|.\nThe drawer items can also be independently customized.</string>
    <string name="nav_containers_7_2">The appearance of the whole drawer can also be changed by applying the |width| modifier and setting a custom scrim color.</string>
    <string name="nav_containers_8_1">Instead of using the index of selected item to determine the current route, consider accessing the current |navBackStackEntry| directly from the controller.\nUsing this approach you can also access current destination.\nTo check if given navigation item should be marked as selected, you can use |NavDestination.hasRoute| method.</string>
    <string name="nav_containers_8_2">By obtaining data directly from the controller, the UI will update automatically with every navigation change, even after pressing the system back button.</string>
    <string name="nav_containers_8_3">When navigating to another destination you can use the |NavOptionsBuilder| to prevent launching the same composable multiple times by setting |launchSingleTop| to *true*.\nYou can also specify to save and restore state of the destination.</string>
    <string name="quiz_nav_ctr_host_1">What objects can you use for typesafe navigation?</string>
    <string name="quiz_nav_ctr_host_1_1">Only objects annotated with *@Serializable*</string>
    <string name="quiz_nav_ctr_host_1_2">Only enum values</string>
    <string name="quiz_nav_ctr_host_1_3">Any object or class annotated with *@Serializable*</string>
    <string name="quiz_nav_ctr_host_2">How can you navigate to the previous destination?</string>
    <string name="quiz_nav_ctr_host_2_1">By using the *navigateBack* method</string>
    <string name="quiz_nav_ctr_host_2_2">By using the *navigateUp* method</string>
    <string name="quiz_nav_ctr_host_2_3">By invoking the *onBack* callback</string>
    <string name="quiz_nav_ctr_host_3">How can you pass data when navigating?</string>
    <string name="quiz_nav_ctr_host_3_1">By using class with fields as route object</string>
    <string name="quiz_nav_ctr_host_3_2">By using multiple route objects</string>
    <string name="quiz_nav_ctr_host_3_3">By saving the arguments with |rememberSaveable|</string>
    <string name="quiz_nav_containers_1">How can you programmatically open the navigation drawer?</string>
    <string name="quiz_nav_containers_1_1">By setting the *isOpen* parameter of the drawer to *true*</string>
    <string name="quiz_nav_containers_1_2">By calling the *drawerState.open* method</string>
    <string name="quiz_nav_containers_1_3">By calling the *drawerState.animateState* method</string>
    <string name="quiz_nav_containers_3">How can you synchronize the navigation elements with the *navController* state?</string>
    <string name="quiz_nav_containers_3_1">By using the *currentNavBackStackEntryAsState* method</string>
    <string name="quiz_nav_containers_3_2">By using the *navController* inside a *DisposableEffect*</string>
    <string name="quiz_nav_containers_3_3">By using no more than 2 destination routes per *navController*</string>
    <string name="quiz_nav_containers_2">How can you easily create a bottom navigation bar?</string>
    <string name="quiz_nav_containers_2_1">By using a bottom aligned *Box*</string>
    <string name="quiz_nav_containers_2_2">By using the *BottomNavigationBar* compose</string>
    <string name="quiz_nav_containers_2_3">By using the *NavigationBar* inside a *Scaffold*</string>
    <string name="quiz_back_1">How can you conditionally disable a *BackHandler*</string>
    <string name="quiz_back_1_1">By using the *isDisabled* parameter</string>
    <string name="quiz_back_1_2">By using the *enabled* parameter</string>
    <string name="quiz_back_1_3">By using an *if* statement inside the handler\'s lambda</string>
    <string name="quiz_back_2">How can you handle multiple consecutive backs?</string>
    <string name="quiz_back_2_1">By using the *CombinedBackHandler*</string>
    <string name="quiz_back_2_2">By using nested handlers</string>
    <string name="quiz_back_2_3">By using multiple handlers</string>
    <string name="nav_suite_1_change">Change layout type</string>
    <string name="nav_suite_1_current">Current layout: %1$s</string>
    <string name="notification_2_send">Send notification</string>
    <string name="notification_2_title">Custom notification!</string>
    <string name="notification_2_content">Notification content text</string>
    <string name="notification_3_content">Click to open the app</string>
    <string name="notification_4_action_label">Open app</string>
    <string name="notification_4_null_action">Disabled button</string>
    <string name="notification_6_block_title">Notification with long text</string>
    <string name="notification_6_block_content">Notification content text</string>
    <string name="notification_cancel_all">Cancel all notifications</string>
    <string name="notification_public_title">Public notification title</string>
    <string name="notification_private_title">Private message notification</string>
    <string name="notification_1_heading">Creating notification channel</string>
    <string name="notification_2_heading">Sending notifications</string>
    <string name="notification_3_heading">Opening app from notification</string>
    <string name="notification_4_heading">Adding actions</string>
    <string name="notification_5_heading">Grouping notifications</string>
    <string name="notification_6_heading">Notification styles</string>
    <string name="notification_7_heading">Clearing notifications</string>
    <string name="notification_8_heading">Hiding sensitive information</string>
    <string name="lesson_permissions_title">App permissions</string>
    <string name="permission_3_request">Request camera permission</string>
    <string name="permission_granted">Permission granted</string>
    <string name="permission_declined">Permission declined</string>
    <string name="permission_declined_permanently">Permanently declined</string>
    <string name="permissions_1_heading">Declaring app permissions</string>
    <string name="permissions_2_heading">Declaring hardware</string>
    <string name="permissions_3_heading">Requesting permissions</string>
    <string name="permissions_4_heading">Checking granted permissions</string>
    <string name="permissions_5_heading">Permission workflow</string>
    <string name="lesson_camera_titile">Camera</string>
    <string name="permissions_6_open_app_settings">Go to application settings</string>
    <string name="permissions_6_heading">Opening application settings</string>
    <string name="camera_no_permissions">No camera permissions</string>
    <string name="camera_request_permission">Request camera permission</string>
    <string name="camera_switch">Switch camera</string>
    <string name="camera_capture_error">Unexpected error while capturing image</string>
    <string name="camera_take_photo">Take photo</string>
    <string name="camera_open_gallery">Open gallery</string>
    <string name="camera_gallery_no_photos">No photos taken</string>
    <string name="camera_start_recording">Start recording</string>
    <string name="camera_stop_recording">Stop recording</string>
    <string name="dialog_grant_permission">Grant permission</string>
    <string name="dialog_permission_required">Permission required</string>
    <string name="action_needs_permission">This actions requires %1$s permission.</string>
    <string name="permission_permanently_declined">It seems you permanently declined %1$s permission. You can go to the app settings to grant it.</string>
    <string name="camera_genitive">camera</string>
    <string name="notifications_genitive">sending notifications</string>
    <string name="microphone_genitive">microphone</string>
    <string name="camera_recording_no_permissions">No permissions for recording with audio</string>
    <string name="camera_recording_request_permissions">Request permissions for recording with audio</string>
    <string name="camera_1_heading">Installing dependencies</string>
    <string name="camera_2_heading">Displaying camera preview</string>
    <string name="camera_3_heading">Switching the camera</string>
    <string name="camera_4_heading">Taking photos</string>
    <string name="camera_5_heading">Processing photos</string>
    <string name="camera_6_heading">Recording videos</string>
    <string name="capture_succeeded">Capture succeeded</string>
    <string name="capture_failed">Capture failed</string>
    <string name="biometrics_prompt_title">Title of the auth prompt</string>
    <string name="biometrics_prompt_description">Useful description</string>
    <string name="biometrics_prompt_show">Show authorization prompt</string>
    <string name="biometric_prompt_subtitle">Subtitle</string>
    <string name="biometrics_1_heading">Installing dependencies</string>
    <string name="biometrics_2_heading">Creating the prompt</string>
    <string name="biometrics_3_heading">Displaying the prompt</string>
    <string name="biometrics_4_heading">Listening to the results</string>
    <string name="biometrics_5_heading">Allowing device credentials</string>
    <string name="biometrics_6_heading">Setting biometric auth if not present</string>
    <string name="ok" translatable="false">OK</string>
    <string name="notification_6_text">Send text notification</string>
    <string name="notification_6_image">Send image notification</string>
    <string name="notification_6_image_title">Notification with an image</string>
    <string name="lesson_hilt_title" translatable="false">Hilt</string>
    <string name="lesson_room_title">Room DB</string>
    <string name="hilt_1_heading">Installing dependencies</string>
    <string name="hilt_2_heading">Hilt application class</string>
    <string name="hilt_3_heading">Injecting dependencies</string>
    <string name="hilt_4_heading">Defining bindings</string>
    <string name="hilt_5_heading">Binding interfaces</string>
    <string name="hilt_6_heading">Injecting instances</string>
    <string name="hilt_7_heading">Multiple bindings for the same type</string>
    <string name="hilt_8_heading">Predefined qualifiers</string>
    <string name="hilt_9_heading">Generated components</string>
    <string name="hilt_10_heading">Component lifetimes</string>
    <string name="hilt_11_heading">Component scopes</string>
    <string name="room_1_heading">Installing dependencies</string>
    <string name="room_2_heading">Defining entities</string>
    <string name="room_3_heading">Primary keys</string>
    <string name="room_4_heading">Ignoring fields</string>
    <string name="room_5_heading">Creating indices</string>
    <string name="room_6_heading" translatable="false">Data access object (DAO)</string>
    <string name="room_7_heading">Performing queries</string>
    <string name="room_8_heading">Asynchronous DAO</string>
    <string name="room_9_heading">Creating the data base</string>
    <string name="room_10_heading">Returning mapping</string>
    <string name="room_12_heading">One to many relationships</string>
    <string name="room_11_heading">Embedding entities</string>
    <string name="room_13_heading">Many to many relationships</string>
    <string name="permissions_1_1">Permissions in Android are split into multiple categories, including install-time permissions and runtime permissions.\nEach permission\'s type indicates the scope of restricted data your app can access and the actions it can perform.</string>
    <string name="permissions_1_2">Install-time permissions lets your app access data and perform actions that minimally affect the system or other apps.\nThe system automatically grants your app these permissions when the user installs your app.</string>
    <string name="permissions_1_3">Runtime permissions give your app additional access to data or actions that more substantially affect the system and other apps. That is why you need to request runtime permissions in your app before you can use them.</string>
    <string name="permissions_1_4">If your app requires any permissions, either install-time or runtime, you must declare them in your app\'s manifest file:</string>
    <string name="permissions_2_1">Some permissions, such as |CAMERA|, let your app access hardware that not all Android device have.\nIf your app declares one of such permissions, consider wether it is nescessary to use that hardware, and mark it either as required or optional.</string>
    <string name="permissions_2_2">If your app declares some hardware as optional, you can check whether a device has this specific hardware available by using the |hasSystemFeature| method:</string>
    <string name="permissions_3_1">To request runtime permissions you can use the composable function |rememberLauncherForActivityResult| with the |RequestPermission| contract.\nThe |onResult| callback lets you access the information whether the permissions was granted by the user.</string>
    <string name="permissions_4_1">You can check if your app already has been granted permissions with the |ContextCompat.checkSelfPermission| method.</string>
    <string name="permissions_4_2">You can also check if user declined the permission permanently (by declining the request multiple times) using the |ActivityCompat.shouldShowRequestPermissionRationale|. If the result is *false*, then the permissions most probably has been permanently declined.</string>
    <string name="permissions_5_1">The recommended approach for handling runtime permissions has three steps:</string>
    <string name="permissions_5_2">*Check* if the app already has the necessary permission</string>
    <string name="permissions_5_3">*Request the permission* if it has not been granted</string>
    <string name="permissions_5_4">*Explain why the permission is needed* if the user declines, to help them understand its importance for the app\'s functionality</string>
    <string name="permissions_6_1">If a user permanently denies a permission, you can still inform them of its importance within the app’s UI.\nYou may also provide an option to open the app\'s system settings, allowing the user to manually grant the required permissions if they reconsider.</string>
    <string name="permissions_6_2">Example extension function opening the app\'s settings:</string>
    <string name="notification_1_1">To send notifications from your app, first you need to declare the required permission. On Android 13 (API level 33) and higher this is a *runtime permission*.</string>
    <string name="notification_1_2">Starting with Android 8 (API level 26), you also need to register your app\'s notification channel with the system before you can deliver any notifications.\nYou can do this using the |NotificationManager.createNotificationChannel| method. When you create a channel, you can set its name, ID, and importance level.</string>
    <string name="notification_2_1">To send a notification you need to create a object describing its content.\nYou can use the |NotificationCompat.Builder| to set the specific elements of the notification.\nThe only required element is the |smallIcon|.</string>
    <string name="notification_2_2">To send the built notification you can use |NotificationManager.notify| method. It accepts the object describing the notification and its ID. By using the same ID multiple times you can update an existing notification.</string>
    <string name="notification_3_1">Notifications can also be used to open the app that send them. You can add this functionality by creating a *pending intent* and passing it to the notification builder.\nNotifications with |autoCancel| set to *true* will be automatically dismissed after being clicked by the user.</string>
    <string name="notification_4_1">Instead of making the whole notification clickable, you can add a simple button with the |addAction| method. The button will invoke the specified intent when pressed.\nSingle notification can have multiple buttons.</string>
    <string name="notification_5_1">You can display related notifications in a single group. To create a notification group, define a uniqe identifier and assign the notification to the group by passing the identifier to the |setGroup| method.</string>
    <string name="notification_5_2">Grouped notification must have an extra notification that acts as the summary of the group. To mark a notification as summary, use the |setGroupSummary| method.</string>
    <string name="notification_6_1">You can change the appearance of the notification by providing custom *style template* to the |setStyle| method.</string>
    <string name="notification_6_2">Displaying big block of text:</string>
    <string name="notification_6_3">Displaying picture:</string>
    <string name="notification_7_1">You can cancel previously sent notification using the |NotificationManager.cancelAll| to cancel all notifications or |NotificationManager.cancel| to cancel a specific one.</string>
    <string name="notification_8_1">You can hide sensitive information by setting the notification\'s visibility to |VISIBILITY_PRIVATE| or |VISIBILITY_SECRET|.\nNon-public notifications will have its content hidden on the lock screen.</string>
    <string name="notification_8_2">When using the |VISIBILITY_PRIVATE| you can set a public version of the notification to be displayed instead of the one with sensitive data.</string>
    <string name="camera_1_1">The *CameraX* is the recommended library when working with camera in Android.\nYou can install it by adding the following implementations into the |dependencies| block of your app\'s |build.gradle.kts| file:</string>
    <string name="camera_2_1">To obtain a camera controller, you can use the |LifecycleCameraController| function.\nYou can enable specific functionalities for this controller with the |setEnabledUseCases| method.</string>
    <string name="camera_2_2">You can use the |AndroidView| composable to display the camera preview.\nInside the |factory| lambda you can bind the controller to the app\'s lifecycle and set the scaling of the preview.</string>
    <string name="camera_2_3">Before displaying the preview remember to ask for required permissions. Otherwise your app could be halted by |SecurityException|.</string>
    <string name="camera_3_1">You can change the selected camera by setting the |cameraSelector| property of the controller.</string>
    <string name="camera_4_1">You can use the |LifecycleCameraController| to take photos using its |takePicture| method.\nThis method takes two arguments: the task executor and the callback object. In the callback you can access the taken image and handle the potential error.</string>
    <string name="camera_5_1">You can process the taken images by applying matrix transformation on them. The rotation can be especially useful, as the images are captured sideways by default.</string>
    <string name="camera_6_1">The camera controller also allows you to record videos. In order to do that you have to add the |VIDEO_CAPTURE| to the enabled use cases.</string>
    <string name="camera_6_2">To record a video you can use the |startRecording| method. It takes four parameters: the file output options, configuration of the audio, executor and callback.\nYou can set whether to record audio with the |AudioConfig.create| method.</string>
    <string name="camera_6_3">When handling recordings, it is important to ensure that only one is active at any given time. It may be helpful to store the recording object outside of the recording function to prevent multiple simultaneous video captures from starting\n</string>
    <string name="camera_6_4">You can use the callback to listen for the recording events to respond to capture succeeding or to handle any errors.</string>
    <string name="biometrics_1_1">You can add the biometric authentication functionality to your app with the *Biometric* library. You can install it by adding the following dependencies in your app\'s |build.gradle.kts| file:</string>
    <string name="biometrics_1_2">Because the library uses |AppCompatActivity| you should change your activity to inherit from this class.</string>
    <string name="biometrics_1_3">When using |AppCompatActivity| you should also use the |AppCompat| themes in your activity.</string>
    <string name="biometrics_2_1">To create the authentication prompt, you can use the |PromptInfo.Builder()|. It allows you to set the title, subtitle and description to display on the prompt.</string>
    <string name="biometrics_2_2">Before displaying the prompt you should check if the required hardware is present in the device and if it is not currently occupied.\nYou should also handle the possibility of the user has not registered any biometric data.</string>
    <string name="biometrics_3_1">When displaying the prompt you should create a callback to respond to different authentication events.</string>
    <string name="biometrics_4_1">It can be useful to display the result of the authentication on the UI. To do this you can use a |Channel| or |MutableSharedFlow| that will be used to emit results of the authentication.\nCreating a dedicated type to handle all the possible results can simplify the code.</string>
    <string name="biometrics_4_2">In the UI, you can collect the results with the |collectAsStateWithLifecycle| composable function and display relevant information.</string>
    <string name="biometrics_5_1">You can allow the user to also use device credentials in the prompt. This can be done by setting the *allowed authenticators* in the builder to |BIOMETRIC_STRONG or DEVICE_CREDENTIAL|.\nNote that credentials can only be used on devices with API level 30 or greater.</string>
    <string name="quiz_permissions_1">Where are the app\'s permissions declared?</string>
    <string name="quiz_permissions_1_1">In the file with *MainActivity*</string>
    <string name="quiz_permissions_1_2">In the app\'s manifest</string>
    <string name="quiz_permissions_1_3">In the app\'s resources</string>
    <string name="quiz_permissions_2">What are the two main types of permissions?</string>
    <string name="quiz_permissions_2_1">*Static* and *dynamic*</string>
    <string name="quiz_permissions_2_2">*Hardware* and *software*</string>
    <string name="quiz_permissions_2_3">*Install-time* and *runtime*</string>
    <string name="quiz_permissions_3">How can you check whether the app has specific permission?</string>
    <string name="quiz_permissions_3_1">By trying to use it</string>
    <string name="quiz_permissions_3_2">Using the *checkSelfPermission* method</string>
    <string name="quiz_permissions_3_3">Permissions are always granted during installation</string>
    <string name="quiz_notification_1">What permission is required to send notifications?</string>
    <string name="quiz_notification_1_1" translatable="false">*SEND_NOTIFICATIONS*</string>
    <string name="quiz_notification_1_2" translatable="false">*DISPLAY_NOTIFICATIONS*</string>
    <string name="quiz_notification_1_3" translatable="false">*POST_NOTIFICATIONS*</string>
    <string name="quiz_notification_2">What is the required element of a notification?</string>
    <string name="quiz_notification_2_1">Content text</string>
    <string name="quiz_notification_2_2">Group ID</string>
    <string name="quiz_notification_2_3">Small icon</string>
    <string name="quiz_notification_3">When can you set public version for a notification?</string>
    <string name="quiz_notification_3_1">When it has private visibility</string>
    <string name="quiz_notification_3_2">When it is marked as *Internal*</string>
    <string name="quiz_notification_3_3">If it has no content text set</string>
    <string name="quiz_camera_1">How can you enable specific functions of the camera controller?</string>
    <string name="quiz_camera_1_1">By using the *enableFeatures* method</string>
    <string name="quiz_camera_1_2">By using the *setEnabledUseCases* method</string>
    <string name="quiz_camera_1_3">By specifying the allowed features in the manifest</string>
    <string name="quiz_camera_2">Which composable can be used to display the camera view?</string>
    <string name="quiz_camera_2_1" translatable="false">*CameraView*</string>
    <string name="quiz_camera_2_2" translatable="false">*NativeView*</string>
    <string name="quiz_camera_2_3" translatable="false">*AndroidView*</string>
    <string name="quiz_camera_3">How can you change the selected camera?</string>
    <string name="quiz_camera_3_1">By changing the *cameraSelector* property of the controller</string>
    <string name="quiz_camera_3_2">By calling the *switchCamera* method on the controller</string>
    <string name="quiz_camera_3_3">By creating another camera controller</string>
    <string name="quiz_biometrics_1">What is the type of activity used by the *Biometric* library?</string>
    <string name="quiz_biometrics_1_1">Any *Activity*</string>
    <string name="quiz_biometrics_1_2" translatable="false">*FragmentActivity*</string>
    <string name="quiz_biometrics_1_3" translatable="false">*AppCompatActivity*</string>
    <string name="quiz_biometrics_2">How can you allow to use biometrics as well as device credentials?</string>
    <string name="quiz_biometrics_2_1">By calling the *allowDeviceCredentials* method on the prompt builder</string>
    <string name="quiz_biometrics_2_2">By using the *DEVICE_CREDENTIAL* in the prompt authenticators</string>
    <string name="quiz_biometrics_2_3">By using *DeviceCredentialPrompt*</string>
    <string name="hilt_1_1">Hilt is a dependency injection (#DI#) library for Android. It reduces the boilerplate of doing manual DI in your projects.\nHilt provides a standard way to use DI by providing containers for Android classes and managing their lifecycle automatically.</string>
    <string name="hilt_1_2">To install Hilt you should add the |hilt-android-gradle-plugin| to your #project\'s# (not app\'s) |build.grade| file:</string>
    <string name="hilt_1_3">Then, apply the plugin and add the following dependencies in your #app\'s# |build.gradle| file:</string>
    <string name="hilt_2_1">All applications that use Hilt must contain an |Application| class that is annotated with |@HiltAndroidApp|.\nThis annotation triggers the library\'s code generation.</string>
    <string name="hilt_2_2">The generated component is attached to the |Application| object\'s lifecycle and provides dependencies to it.</string>
    <string name="hilt_3_1">When Hilt is set up in your project, it can provide dependencies to other Android classes annotated with |@AndroidEntryPoint|:</string>
    <string name="hilt_3_2">To obtain dependencies from the generated Hilt component, use the |@Inject| annotation to perform field injection:</string>
    <string name="hilt_4_1">To perform the injection, Hilt needs to know how to provide instances of the necessary dependencies. A #binding# contains the needed information.\nOne way to create a binding is #constructor injecton#. Use the |@Inject| annotation on the constructor of a class, to tell Hilt how to provide instances of that class.</string>
    <string name="hilt_5_1">Some types cannot be constructor-injected. For example, you cannot constructor-inject interface or a type that you do not ow, such as a class from an external library. In these cases you can create bindings by using #Hilt modules#.</string>
    <string name="hilt_5_2">A Hilt module is a class that is annotated with |@Module|.</string>
    <string name="hilt_5_3">To inject an interface you can create an abstract function annotated with |@Binds|:</string>
    <string name="hilt_6_1">To provide a type you don\'t own, you can use a regular function annotated with |@Provides|:</string>
    <string name="hilt_7_1">In case where you need to provide different implementations of the same type, you can use multiple bindings using #qualifiers#.\nYou can define the qualifiers by creating an annotation with |@Qualifier|:</string>
    <string name="hilt_7_2">Then, Hilt needs to know how to provide types that correspond with the created qualifiers. You could use a module with |@Provides| to do that.</string>
    <string name="hilt_7_3">You can inject the specific implementation by annotating the field or parameter with the corresponding qualifier:</string>
    <string name="hilt_8_1">Hilt provides some predefined qualifiers, like |@ApplicationContext| and |@ActivityContext|.</string>
    <string name="not_available">N/A</string>
    <string name="hilt_component">Hilt component</string>
    <string name="injector_for">Injector for</string>
    <string name="generated_component">Generated component</string>
    <string name="created_at">Created at</string>
    <string name="destroyed_at">Destroyed at</string>
    <string name="room_1_1">The Room library provides an abstraction layer over SQLite to allow fluent database access. This allows your app to store more complex data in a well-structured manner.\nTo use it in your project, add the following dependencies to your app\'s |build.gradle| file:</string>
    <string name="room_2_1">Entities in Room are regular classes annotated with |@Entity|. To make sure Room has access to a specific field you can make it public or provide getter and setter methods for it.</string>
    <string name="room_2_2">By default, Room uses the class name as the database table name. If you want to change the name of the table, set the |tableName| property of the |@Entity| annotation.\nSimilarly, the field names are used as column names by default. The columns can be named explicitly by adding the |@ColumnName| annotation and setting its |name| property.</string>
    <string name="room_3_1">Each entity must define a primary key. The most straightforward of doing this is to annotate a single field with the |@PrimaryKey|.\nYou can also create a #composite primary key# by listing the columns to be used in the |primaryKeys| property of |@Entity|.</string>
    <string name="room_4_1">By default, Room creates a column for each field of the entity class. You can ignore field you don\'t want to persist by using the |@Ignore| annotation.</string>
    <string name="room_4_2">If your entity inherits field from a base class, you can ignore them by using the |ignoredColumns| property of the |@Entity|.</string>
    <string name="room_5_1">You can create additional indices in your table by using the |indices| property of the |@Entity|:</string>
    <string name="room_6_1">To access the data stored in the tables you can use a *data access object*. DAOs can be defined either as an interface or an abstract class.\nDAOs don\'t have any properties, but they define methods for interacting with the database.</string>
    <string name="room_6_2">The DAO methods can be split into two categories: convenience methods for inserting, updating and deleting, and query methods that let you write your own SQL code.</string>
    <string name="room_7_1">You can return a subset of table\'s columns by defining a special type that holds some of the entity properties.</string>
    <string name="room_7_2">Most of the time, DAO methods need to accept parameters so they can perform filtering operations. Room supports using method parameters as bind parameters in your queries.</string>
    <string name="room_8_1">You can use Kotlin features to write asynchronous queries using suspend functions and |Flow|.</string>
    <string name="room_8_2">"DAO methods that return |Flow| can be used to write observable queries. "</string>
    <string name="room_9_1">To use the database in your app, you have to define an abstract class that inherits from |RoomDatabase| and is annotated with |@Database|.\nThis class should contain parameterless method that returns the associated DAO.</string>
    <string name="room_9_2">After having defined the database class, you can create an instance of the DB using the Room builder:</string>
    <string name="room_10_1">You can return data from multiple tables by creating DAO method that returns |Map|:</string>
    <string name="room_11_1">When an entity contains several fields you can still split it into multiple classes using the |@Embedded| annotation.</string>
    <string name="room_12_1">To define a one-to-many relationship, first create a class for the two entities. The child entity must include a field that references the primary key of the parent entity.</string>
    <string name="room_11_2">The table representing a |User| object will contain columns from both classes: |id|, |name|, |address|, |street| and |city|.</string>
    <string name="room_11_3">If an entity has multiple embedded fields of the same type, you can keep each column unique by setting the |prefix| property.</string>
    <string name="room_12_2">Then, create a new data class representing the relation between entities. This class should hold an instance to the parent entity and list of child entities, annotated with |@Relation|.</string>
    <string name="room_12_3">Method returning entities with such relationship requires Room to run two queries, so it is recommended to add the |@Transaction| annotation to perform this operation atomically.</string>
    <string name="room_13_1">Many-to-many relationships can be created similarity to one-to-many, with the important addition of linking entity.\nThis linking entity must include reference to primary keys of both of the entities in the relation.</string>
    <string name="room_13_2">Next, model the relationship between the entities by using the |associateBy| property in the |@Relation| annotation to identify the cross-reference entity.</string>
    <string name="room_13_3">As in the previous case, this operation also requires multiple queries to be performed, so adding |@Transaction| annotation is recommended.</string>
    <string name="hilt_9_1">For each Android class in which you can perform field injection, there\'s an associated Hilt component that you can use in the |@InstallIn| annotation.</string>
    <string name="animating_values_1_1">The |animate*AsState| functions are the simples animation API in Compose for animating a single value. You only have to provide the target value, and the API starts the animation.</string>
    <string name="animating_values_1_2">Jetpack Compose provides functions that can animate |Float|, |Color|, |Dp|, |Size|, |Offset|, |Rect|, |Int|, |IntOffset| and |IntSize|.\nYou can easily add support for other data types by providing a |TwoWayConverter| to the animation function.</string>
    <string name="animating_values_2_1">Animating |DP| can be useful for smoothly changing the size or padding of the UI elements.</string>
    <string name="animating_values_3_1">You can customize the animation specifications by providing an |AnimationSpec|. You can use it to create physics based animations using |spring|, animate between values with |tween| or create |keyframes|.</string>
    <string name="animating_values_4_1">You can animate multiple values between states with the |Transition| class. The states can be of any type, most commonly an |enum|.</string>
    <string name="animating_values_4_2">The |updateTransition| composable function creates and remembers an instance of |Transition|.</string>
    <string name="animating_values_4_3">After creating the object, you can use its extension functions to define a child animation.</string>
    <string name="animating_values_5_1">|InfiniteTransition| behaves similarly to the |Transition|, but the animation starts as soon as it enters the composition and stop only after being removed.</string>
    <string name="animated_visibility_1_1">The |AnimatedVisibility| composable animates the appearance and disappearance of its content.</string>
    <string name="animated_visibility_1_2">By default, the content appears by fading in and expanding, and disappears by fading out and shrinking.\nBy using the |AnimatedVisibility| inside a column or a row, the default animations are changed to changed to better match its surrounding.</string>
    <string name="animated_visibility_2_1">Jetpack Compose provides multiple built in types of animations:</string>
    <string name="animated_visibility_3_1">You can combine different types of animations with the addition operator. Note that you cannot combine *enter* animations with *exit* ones.</string>
    <string name="animated_visibility_4_1">Inside the scope of the |AnimatedVisibility| you can apply the |animateEnterExit| modifier to animate inner composables independently of the main container.</string>
    <string name="animated_visibility_5_1">To animate changes in content, you can use the |AnimatedContent| composable. It allows you to specify the transitions to apply to ensure a smooth change.</string>
    <string name="animated_visibility_5_2">The |togetherWith| infix function is useful for linking enter and exit transitions.</string>
    <string name="viewmodel_1_1">The *ViewModel* is responsible for exposing state to the UI and encapsulating related business logic. Its main advantage is that it persist through configuration changes (like rotating the screen).</string>
    <string name="viewmodel_1_2">To create a ViewModel you should first add the following implementation to your app\'s |build.gradle| file:</string>
    <string name="viewmodel_2_1">After creating the ViewModel you can define the state it should expose to the UI.</string>
    <string name="viewmodel_2_2">To make sure the UI reacts to changes to the state, you can use a |StateFlow|.\nStateFlow acts as a data holder that emits the current value and new state updates.</string>
    <string name="viewmodel_3_1">To access the ViewModel data in the UI, you can use the |viewModel&lt;T&gt;| composable function to retrieve the instance of the ViewModel associated with curent navigation route (or activity).</string>
    <string name="viewmodel_3_2">After retrieving the instance you can use |collectAsState| or |collectAsStateWithLifecycle| composable functions to access the current value of the |StateFlow|.</string>
    <string name="viewmodel_4_1">"You can use the |viewModelScope| to perform asynchronous business logic, that shouldn't be handled by the UI. "</string>
    <string name="viewmodel_4_2">The ViewModel exists in the app from the start of the activity to when it is destroyed. You can clear any ongoing tasks by overriding the |onCleared| method.</string>
    <string name="viewmodel_5_1">ViewModels should not know about the details of UI implementation.</string>
    <string name="viewmodel_5_2">As ViewModels potentially can live longer than its owner, they should not hold any references to lifecycle-related APIs such as the |Context| or |Resources| to prevent memory leaks.</string>
    <string name="viewmodel_5_3">Don\'t pass ViewModels to other classes or functions. You should keep them close to your Activity or screen level composable. Lower level components should only access the absolutely necessary data.</string>
    <string name="persistent_1_1">More often than not, Android application need to store small amounts of data, for example saving the user preferences and settings. The |DataStore| library allows you to easily work with this type of data.</string>
    <string name="persistent_1_2">To install it, add the following implementation to your app\'s |build.grade| file:</string>
    <string name="persistent_2_1">To create the |DataStore| you can use the |preferencesDataStore| delegate with the |Context| as receiver. You should also create unique name for the store.</string>
    <string name="persistent_2_3">To read data from the store you have to create a *PreferencesKey* that matches the type of your data.</string>
    <string name="persistent_2_2">Preferences DataStore exposes the data store as a |Flow&lt;T&gt;| that will emit every time a preference has changed. Instead of exposing the whole object, you can wrap it in a helper class.</string>
    <string name="persistent_3_1">You can use the *ViewModel* to manage and further encapsulate the preferences store.</string>
    <string name="persistent_3_2">You can use an |AndroidViewModel| instead of regular one to access the |Context| needed for operations with the store.</string>
    <string name="persistent_4_1">If you are exposing asynchronous methods accessing the saved data by your ViewModel, you can use them inside |LaunchedEffect|.</string>
    <string name="quiz_hilt_1">Which annotation is required on the *Application* class when using Hilt?</string>
    <string name="quiz_hilt_1_1" translatable="false">*@HiltApp*</string>
    <string name="quiz_hilt_1_2" translatable="false">*@AndroidEntryPoint*</string>
    <string name="quiz_hilt_1_3" translatable="false">*@HiltAndroidApp*</string>
    <string name="quiz_hilt_2">How can you inject an interface?</string>
    <string name="quiz_hilt_2_1">You cannot inject interfaces</string>
    <string name="quiz_hilt_2_2">By using function annotated with *@Provides*</string>
    <string name="quiz_hilt_2_3">By using abstract function annotated with *Binds*</string>
    <string name="quiz_hilt_3">How can you inject specific implementation of a given type?</string>
    <string name="quiz_hilt_3_1">By using the generic *@Inject&lt;T&gt;* annotation</string>
    <string name="quiz_hilt_3_2">By using qualifiers</string>
    <string name="quiz_hilt_3_3">By creating separate *Hilt module*</string>
    <string name="quiz_room_1">How can you change the name of the DB table?</string>
    <string name="quiz_room_1_1">By using the *tableName* parameter of the *@Entity* annotation</string>
    <string name="quiz_room_1_2">The table name always matches the type name</string>
    <string name="quiz_room_1_3">By creating a *TableInfo* object</string>
    <string name="quiz_room_2">How can you ignore an inherited field in an entity?</string>
    <string name="quiz_room_2_1">By annotating the field in the base class with *@Ignore*</string>
    <string name="quiz_room_2_2">By providing a default value for the field</string>
    <string name="quiz_room_2_3">By using the *ignoredColumns* property of the *@Entity* annotation</string>
    <string name="quiz_room_3">How can you return data from multiple tables in one DAO method?</string>
    <string name="quiz_room_3_1">By returning a mapping</string>
    <string name="quiz_room_3_2">By returning a |Flow&lt;T&gt;|</string>
    <string name="quiz_room_3_3">It is not possible</string>
    <string name="quiz_viewmodel_1">How can you access the *ViewModel* inside a composable function?</string>
    <string name="quiz_viewmodel_1_1">By using the *viewModel&lt;T&gt;* function</string>
    <string name="quiz_viewmodel_1_2">By using the *LocalViewModel.current*</string>
    <string name="quiz_viewmodel_1_3">By accessing it from *Context*</string>
    <string name="quiz_viewmodel_2">How can you cancel ongoing task when the ViewModel is destroyed?</string>
    <string name="quiz_viewmodel_2_1">By calling the *OnDestroy* method</string>
    <string name="quiz_viewmodel_2_2">By overriding the *OnCleared* method</string>
    <string name="quiz_viewmodel_2_3">By throwing the *OperationCanceledException*</string>
    <string name="quiz_persistent_1">*DataStore* is best suited for working with:</string>
    <string name="quiz_persistent_1_1">Large and well-structured datasets</string>
    <string name="quiz_persistent_1_2">Rapidly changing data</string>
    <string name="quiz_persistent_1_3">Simple datasets</string>
    <string name="quiz_persistent_2">How can you create the *DataStore*?</string>
    <string name="quiz_persistent_2_1">By calling its public constructor</string>
    <string name="quiz_persistent_2_2">By using the *preferencesDataStore* delegate</string>
    <string name="quiz_persistent_2_3">By accessing it from the *Context*</string>
    <string name="quiz_persistent_3">What type of object is needed to access the data in the DataStore?</string>
    <string name="quiz_persistent_3_1" translatable="false">*DataScheme*</string>
    <string name="quiz_persistent_3_2" translatable="false">*PreferencesKey*</string>
    <string name="quiz_persistent_3_3" translatable="false">*LiveData*</string>
    <string name="quiz_state_1">How can you animate an *Int* value?</string>
    <string name="quiz_state_1_1">By using *animateIntAsState*</string>
    <string name="quiz_state_1_2">By using *animateState&lt;T&gt;*</string>
    <string name="quiz_state_1_3">By using *FloatAnimator*</string>
    <string name="quiz_state_2">How can you animate multiple values simultaneously?</string>
    <string name="quiz_state_2_1">By using *SharedAnimator*</string>
    <string name="quiz_state_2_2">By using *Transition*</string>
    <string name="quiz_state_2_3">By using the *GlobalAnimator*</string>
    <string name="quiz_content_1">How can you combine different transitions?</string>
    <string name="quiz_content_1_1">WIth the *combine* extension function</string>
    <string name="quiz_content_1_2">With the addition operator</string>
    <string name="quiz_content_1_3">With the multiplication operator</string>
    <string name="quiz_content_2">Can you animate independently composables inside *AnimatedVisibility*?</string>
    <string name="quiz_content_2_1">Only when the *AnimatedVVisibility* is placed in a row or column</string>
    <string name="quiz_content_2_2">Yes, using the *animateEnterExit* modifier</string>
    <string name="quiz_content_2_3">Is it not possible</string>
    <string name="quiz_content_3">What function can be used to animate between different content?</string>
    <string name="quiz_content_3_1" translatable="false">*AnimatedVisibility*</string>
    <string name="quiz_content_3_2" translatable="false">*AnimatedContent*</string>
    <string name="quiz_content_3_3" translatable="false">*AnimatedView*</string>
    <string name="side_effects_1_1">To perform work over the life of a composable and be able to call suspend functions, you can use the |LaunchedEffect| composable.\nWhen it enters the composition, it launches a coroutine with the block of code passed as a parameter. This coroutine will be cancelled if |LaunchedEffect| leaves the composiiton.</string>
    <string name="side_effects_1_2">If |LaunchedEffect| is recomposed with different keys, the existing coroutine will be cancelled and new one will be launched.</string>
    <string name="side_effects_2_1">In order to launch a coroutine outside of a composable use |rememberCoroutineScope|. This coroutine will still be canceled when the composable leaves the composition.</string>
    <string name="side_effects_3_1">For side effects that should be disposed of after the composable leaves the composition or if the keys change, use |DisposableEffect|.\nUse the |onDispose| function to perform any cleanup needed.</string>
    <string name="side_effects_4_1">You can share state of composables with objects not managed by Compose with the |SideEffect| function.\n|SideEffect| guarantees that the effect will be executed after every successful recomposition.</string>
    <string name="side_effects_5_1">In some cases, you might want to capture a value in such way, that if it changes it won\'t restart the effect (as in |LaunchedEffect|).\nTo do this you can use the |rememberUpdatedState|. It creates a reference to the value which can be later updated.</string>
    <string name="quiz_side_effects_1">When does *LaunchedEffect* restart its coroutine?</string>
    <string name="quiz_side_effects_1_1">Only on initial composition</string>
    <string name="quiz_side_effects_1_2">When its *restart* method gets invoked</string>
    <string name="quiz_side_effects_1_3">When it gets recomposed with different keys</string>
    <string name="quiz_side_effects_2">How can you perform cleanup when composable leaves the composition?</string>
    <string name="quiz_side_effects_2_1">All resources are automatically disposed when composables exit the composition</string>
    <string name="quiz_side_effects_2_2">By using the *DisposableEffect*</string>
    <string name="quiz_side_effects_2_3">By overriding the *onCleanup* method</string>
    <string name="quiz_side_effects_3">When should you use *SideEffect*?</string>
    <string name="quiz_side_effects_3_1">When you want to perform some background operation</string>
    <string name="quiz_side_effects_3_2">When you want to control the lifecycle of the composable</string>
    <string name="quiz_side_effects_3_3">When you want to share state of the composable with other objects</string>
    <string name="saved_lessons">Saved lessons</string>
    <string name="nav_transitions_2_nav_back">Navigate back</string>
    <string name="nav_transitions_1_heading">Enter and exit transitions</string>
    <string name="nav_transitions_2_heading">PopEnter and popExit</string>
    <string name="nav_transitions_3_heading">Per-route animations</string>
    <string name="nav_transitions_4_heading">Reusing transitions</string>
    <string name="nav_transitions_1_1">You can customize the |NavHost| animations with the |enterTransition| and |exitTransition| parameters.\nThe transitions work just like with the |AnimatedVisibility|.</string>
    <string name="nav_transitions_2_1">You can also provide different |pop| transitions, for when the user navigates back. By default they are the same as the \"forward\" transitions.</string>
    <string name="nav_transitions_3_1">Instead of using the same animations for every route, you can set different transitions for different routes using the |composable&lt;T&gt;| function parameters.</string>
    <string name="nav_transitions_4_1">You can also reuse the specific transition combination by creating an extension function for the |NavGraphBuilder| class.\nDoing so can help with managing the multiple transition parameters while still allowing you to fully customize each route.</string>
    <string name="quiz_nav_transitions_1">How can you set different transitions for navigating \"forward\" and \"backward\" when using *NavHost*?</string>
    <string name="quiz_nav_transitions_1_1">By using the *forwardTransition* and *backwardTransition* parameters</string>
    <string name="quiz_nav_transitions_1_2">By using the *AnimatedNavHost* composable</string>
    <string name="quiz_nav_transitions_1_3">By using the regular and *pop* transition parameters</string>
    <string name="quiz_nav_transitions_2">How can you set different transitions for a specific route?</string>
    <string name="quiz_nav_transitions_2_1">By placing the route inside the *AnimateTransition* block</string>
    <string name="quiz_nav_transitions_2_2">By using the *transition* parameters of the *composable&lt;T&gt;* method</string>
    <string name="quiz_nav_transitions_2_3">By creating a separate *NavHost* for that route</string>
    <string name="bottom_sheet_1_1">You can create a bottom sheet you can use the |ModalBottomSheet| composable. To programmatically open and close the sheet you can use the |SheetState|, which you can access by using |rememberModalSheetState|.</string>
    <string name="bottom_sheet_1_2">To smoothly close the sheet, first wait for the closing animation to finish and then hide it completely.</string>
    <string name="bottom_sheet_2_1">You can partially extend the sheet by setting the |skipPartiallyExpanded| to *false* and making it fill max height with a modifier.\nThis allows the user to make the sheet full screen or to dismiss it easily.</string>
    <string name="bottom_sheet_3_1">You can customize the bottom sheet by changing its width and the drag handle. You can use the |maxSheetWidth| and |dragHandle| parameters to do this.</string>
    <string name="bottom_sheet_3_2">The content of the handle can be any composable, but it is important to keep it readable for the user.</string>
    <string name="bottom_sheet_4_1">You can also change the |containerColor|, |contentColor| and the |shape| of the sheet.\nThe color of screen overlay, visible when the sheet is opened, can be changed with the |scrimColor| parameter.</string>
    <string name="quiz_bottom_sheet_1">How can you close the *ModalBottomSheet*?</string>
    <string name="quiz_bottom_sheet_1_1">By clicking outside it</string>
    <string name="quiz_bottom_sheet_1_2">By using the *animateClose* method on the *sheetState*</string>
    <string name="quiz_bottom_sheet_1_3">By using the *hide* method on the *sheetState*</string>
    <string name="quiz_bottom_sheet_1_4">By using the *onCloseRequest* parameter</string>
    <string name="quiz_bottom_sheet_2">How can you partially open the bottom sheet?</string>
    <string name="quiz_bottom_sheet_2_1">By creating *AnchorPoint*s and passing it to the composable</string>
    <string name="quiz_bottom_sheet_2_2">By making the sheet full screen and setting the *skipPartiallyOpen* parameter to *false*</string>
    <string name="quiz_bottom_sheet_2_3">By using the *StaggeredBottomSheet* composable</string>
    <string name="quiz_bottom_sheet_3">How can you change the overlay color on the screen when the *ModalBottomSheet* is opened?</string>
    <string name="quiz_bottom_sheet_3_1">With the *overlayColor* parameter</string>
    <string name="quiz_bottom_sheet_3_2">With the *scrimColor* parameter</string>
    <string name="quiz_bottom_sheet_3_3">With the *containerColor* parameter</string>
    <string name="pager_1_1">To allow your user to swipe through content horizontally or vertically, you can use the |HorizontalPager| and |VerticalPager| composables.</string>
    <string name="pager_1_2">Horizontal pager:</string>
    <string name="pager_1_3">Vertical pager:</string>
    <string name="pager_2_1">Pages in both *pagers* are lazily composed when required. This means that pages that are not visible to the user are not present in the composition.</string>
    <string name="pager_2_2">"You can change the number of pages composed around the currently displayed one with the |beyondBoundsPageCount| parameter. It defaults to zero. "</string>
    <string name="pager_3_1">You can control the position of the pager with the |scrollToPage| and |animateScrollToPage| methods of the |pagerState|.\nYou can also disable scrolling with gestures by setting the |userScrollEnbaled| parameter to *false*</string>
    <string name="pager_4_1">You can observe the current page of the pager by creating a |snapshotFlow| from the |currentPage|, |settledPage| or |targetPage| properties of the |pagerState|.</string>
    <string name="pager_5_1">It can be useful to display some kind of a page indicator. You can crate a simple one by repeating |Box|es inside a row, that is aligned to the bottom.</string>
    <string name="pager_5_2">You can change the color of one of the boxes to indicate the current page.</string>
    <string name="pager_6_1">By default, pager displays only one page at a time. You can change it by setting the |pageSize| parameter to |Fixed|, or by creating a custom |PageSize| object.</string>
    <string name="quiz_pager_2">How can you control the position of the pager?</string>
    <string name="quiz_pager_2_1">By setting the value of the *currentPage* property</string>
    <string name="quiz_pager_2_2">By using the *animateScrollToPage* method</string>
    <string name="quiz_pager_2_3">By using the *requestPage* method</string>
    <string name="quiz_pager_1">How can you change the number of pages composed around the currently displayed one?</string>
    <string name="quiz_pager_1_1">It is not possible to change this value</string>
    <string name="quiz_pager_1_2">With the *beyondBoundsPageCount* parameter</string>
    <string name="quiz_pager_1_3">With the *overdrawCount* parameter</string>
    <string name="quiz_pager_3">How can you display more pages in the pager at the same time?</string>
    <string name="quiz_pager_3_1">By changing the *displayedPages* parameter</string>
    <string name="quiz_pager_3_2">By using a custom *PageSize* object</string>
    <string name="quiz_pager_3_3">By making the pager fill whole screen</string>
    <string name="no_saved_lessons">No saved lessons</string>
    <string name="bookmark_lesson">Bookmark</string>
    <string name="unbookmark_lesson">Unbookmark</string>
    <string name="bookmarked_lesson_template">Bookmarked: %1$s</string>
    <string name="unbookmarked_lesson_template">Unbookmarked: %1$s</string>
</resources>